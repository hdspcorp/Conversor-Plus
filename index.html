<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conversor</title>
  <style>
   :root{
  /* Padrão corporativo: grafite + verde suave */
  --bg:#0b1016;        /* fundo principal (menos azulado) */
  --fg:#d8dee6;        /* texto principal (menos branco) */
  --muted:#98a3b0;     /* texto secundário mais discreto */
  --acc:#94A3B8;       /* slate-400 (cinza-azulado desaturado) */
  --card:#0e141b;      /* cartões/espaços internos */
  --border:#1c2733;    /* bordas discretas */
}
header .note{
  display:block;              /* responsivo */
  margin: 6px 0 0 0;
  font-size: 13px;
  color: var(--muted);
  opacity:.9
}
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:var(--bg); color:var(--fg); }
    header { padding:20px 24px; border-bottom:1px solid var(--border); background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0)); position:relative; }
    h1 { margin:0; font-size:22px; }
    main { max-width: min(1920px, 96vw); margin:0 auto; padding:24px 32px; }
    .grid { display:grid; gap:16px; grid-template-columns: repeat(12, 1fr); }
.col-4 { grid-column: span 4; }
.col-8 { grid-column: span 8; }
.col-6 { grid-column: span 6; }
.col-12 { grid-column: span 12; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:10px; padding:12px; box-shadow:0 12px 32px rgba(0,0,0,.32); }
    .card h2 { margin:0 0 12px; font-size:18px; }
    label { display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }
    input[type="number"], select, input[type="text"], textarea { width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border); background:#121824; color:var(--fg); }
    .btn { cursor:pointer; border:none; border-radius:12px; padding:10px 14px; background:var(--acc); color:#0b1016; font-weight:700; transition: filter .12s ease, transform .12s ease; }
    .btn:hover { filter: brightness(1.04); transform: translateY(-0.5px); }
    .btn:active { filter: brightness(0.98); transform: translateY(0); }
    .btn.ghost { background:#1a2330; color:var(--fg); }
    .btn.ghost:hover { filter: brightness(1.06); transform: translateY(-0.5px); }
    .btn.ghost:active { filter: brightness(0.98); transform: translateY(0); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .list { max-height:220px; overflow:auto; border:1px solid var(--border); border-radius:12px; padding:10px; background:#121824; font-size:12px; }
    .stats { display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:12px; margin-top:10px; }
    .stat { background:#121824; border:1px solid var(--border); border-radius:12px; padding:10px; font-size:13px; color:var(--muted); }
    .stat strong { display:block; font-size:16px; color:var(--fg); }
    .bar { height:10px; background:#121824; border:1px solid rgba(255,255,255,.05); border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; width:0%; background:linear-gradient(90deg, #94A3B8, #CBD5E1); }
    pre { white-space: pre-wrap; background:#121824; border:1px solid var(--border); border-radius:12px; padding:12px; font-size:12px; }
    .downloads a { display:inline-block; margin:6px 6px 0 0; padding:8px 10px; background:#1b2430; border:1px solid var(--border); border-radius:8px; color:var(--fg); text-decoration:none; font-size:13px; box-shadow: 0 4px 10px rgba(0,0,0,.18); }
    .pill { font-size:11px; padding:4px 8px; border:1px solid var(--border); border-radius:999px; background:#121824; color:var(--muted); }
    small { color:var(--muted); }

   /* Segmented control (modo de saída) — destaque premium */
.seg-wrap { display:flex; gap:10px; flex-wrap:wrap; }
.seg {
  display:inline-flex; align-items:center; cursor:pointer; user-select:none;
  padding:10px 14px; border-radius:14px;
  background:#121824; border:1px solid var(--border);
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
  transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
}
.seg:hover{ transform: translateY(-1px); box-shadow:0 10px 24px rgba(0,0,0,.28); }
.seg input{ display:none; }
.seg span{ font-size:14px; font-weight:600; color:var(--muted); letter-spacing:.2px; }

.seg input:checked + span{
  color:#0b1220;
  background: linear-gradient(135deg, #CBD5E1 0%, #94A3B8 100%); /* slate claro → slate médio */
  -webkit-background-clip:text; -webkit-text-fill-color:transparent;
}
.seg:has(input:checked){
  border-color: #94A3B8;
  box-shadow: 0 8px 26px rgba(148,163,184,.22), inset 0 1px 0 rgba(255,255,255,.08);
}

    .muted { color:var(--muted); font-size:12px; }
    .dim { opacity:.6; pointer-events:none; filter:saturate(.7); }

	/* ——— App Switcher: botão + menu dropdown ——— */
.app-switcher {
  position: absolute;
  right: 16px;
  top: 16px;
  z-index: 1000;
}
.app-switcher__btn {
  border: 1px solid var(--border, rgba(255,255,255,.15));
  background: linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  color: var(--fg, #e5e7eb);
  padding: 8px 12px;
  border-radius: 12px;
  font-weight: 700;
  letter-spacing: .2px;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(0,0,0,.25);
  backdrop-filter: blur(6px);
}
.app-switcher__btn:hover { transform: translateY(-1px); }
.app-switcher__menu {
  position: absolute;
  right: 0;
  margin-top: 8px;
  min-width: 260px;
  padding: 8px;
  border-radius: 14px;
  border: 1px solid var(--border, rgba(255,255,255,.12));
  background: linear-gradient(180deg, rgba(15,23,42,.98), rgba(15,23,42,.95));
  box-shadow: 0 20px 40px rgba(0,0,0,.35);
  display: none;
}
.app-switcher.open .app-switcher__menu { display: block; }

.app-switcher__item {
  display: flex; align-items: center; gap: 10px;
  padding: 10px 10px; border-radius: 10px; text-decoration: none;
  color: var(--fg, #e5e7eb);
  border: 1px solid transparent;
}
.app-switcher__item small { color: var(--muted, #9aa4b2); display:block; margin-top:2px }
.app-switcher__item:hover {
  background: rgba(255,255,255,.04);
  border-color: rgba(255,255,255,.08);
}

/* === Ajuda flutuante (FAB) canto inferior direito === */
.help-fab{
  position: fixed;
  right: 18px;
  bottom: 18px;
  z-index: 30000;
}

.help-hint{
  position: relative;
  display: inline-flex;
  justify-content: center;
  align-items: center;
  width: 36px; height: 36px;
  border-radius: 50%;
  background: var(--acc);
  color: #0b1016;
  font-weight: 800;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
}
.help-hint:focus{ outline: 2px solid rgba(255,255,255,.25); outline-offset: 3px; }

/* Pop-up compacto, abre para CIMA */
.help-bubble{
  position: absolute;
  bottom: calc(100% + 12px);
  right: 0;
  left: auto;

  /* largura confortável e limites de viewport */
  width: min(560px, 94vw);
  min-width: 360px;
  max-height: min(76vh, 620px);
  overflow: auto;

  background: var(--card);
  /* texto neutro, chamativo mas suave (opacidade) */
  color: #d8dee6CC;

  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 14px 16px;

  box-shadow: 0 18px 40px rgba(0,0,0,.45);
  display: none;
  z-index: 1;

  /* >>> chave para tirar o negrito herdado do .help-hint <<< */
  font-weight: 400;

  /* leitura */
  font-size: 12px;
  line-height: 1.5;
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* Tipografia do conteúdo interno (compacta e hierárquica) */
/* Título e subtítulo em destaque (cor “cheia” no título) */
.help-bubble .hb-title{
  font-weight: 700;         /* negrito só aqui */
  font-size: 13px;
  letter-spacing: .2px;
  margin: 0 0 8px 0;
  color: var(--fg);
}
.help-bubble .hb-section{
  margin: 10px 0 12px 0;
}
.help-bubble .hb-section .hb-sub{
  font-weight: 600;         /* semi-negrito só no subtítulo */
  margin-bottom: 4px;
  color: #d8dee6E6;         /* levemente mais forte que o corpo */
}

/* Corpo do texto: sem negrito */
.help-bubble p{ margin: 4px 0 6px 0; }
.help-bubble ul{ margin: 6px 0 6px 16px; padding: 0; }
.help-bubble li{ margin-bottom: 4px; }
.help-bubble .hb-flow{
  margin-top: 10px;
  font-weight: 400;         /* sem negrito no rodapé */
}

/* Remove negrito de qualquer <strong>/<b> no corpo das seções */
.help-bubble .hb-section strong,
.help-bubble .hb-section b{
  font-weight: 400 !important;
}

/* Exibir em hover/foco */
.help-hint:hover .help-bubble,
.help-hint:focus .help-bubble,
.help-hint:focus-within .help-bubble{
  display: block;
}

/* Mobile: posicionamento confortável */
@media (max-width: 520px){
  .help-fab{ right: 12px; bottom: 12px; }
  .help-bubble{
    right: -6px;
    max-width: calc(100vw - 24px);
  }
}
/* --- Pesquisa (UI refinada: containers separados) --- */
.result-item{
  padding:12px; margin-bottom:8px;
  border:1px solid var(--border);
  border-radius:12px; background:#0f1621;
  cursor:pointer;
}
.result-item:hover{ background:#121b28; }
.result-item strong{ color:var(--fg); }

.search-toolbar { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
.search-toolbar .btn { padding:8px 12px; border-radius:10px; }

/* Grupo de ações da Prévia — organização consistente */
.preview-actions { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.preview-actions .btn { padding:8px 12px; border-radius:10px; }

/* Coluna esquerda “grudada” no topo ao rolar */
.card.sticky { position: sticky; top: 12px; align-self: flex-start; }
#viewPesquisa .card.sticky { max-height: calc(100vh - 120px); overflow: auto; }

.status-line{
  display:flex; gap:10px; align-items:center; flex-wrap:wrap;
  margin-top:8px;
}
/* Semáforo (status dos conectores) – agora com "bolinha" colorida */
#driveStatus, #importStatus{
  background: var(--surface-1);
  color: var(--muted);
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

/* bolinha à esquerda */
#driveStatus::before, #importStatus::before{
  content: '';
  width: 10px; height: 10px;
  border-radius: 50%;
  background: #9aa4b2; /* cinza por padrão */
  display: inline-block;
  flex: 0 0 10px;
}

/* estados – apenas a bolinha muda de cor */
#driveStatus.status--idle::before, #importStatus.status--idle::before{ background: #9aa4b2; }
#driveStatus.status--ok::before,   #importStatus.status--ok::before  { background: #16a34a; }
#driveStatus.status--err::before,  #importStatus.status--err::before { background: #ef4444; }

/* melhoria de alinhamento da barra de busca */
.search-toolbar { display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
.search-toolbar label{ display:inline-flex; align-items:center; gap:6px; margin:0; white-space:nowrap; }
.search-toolbar input[type="text"]{ flex:1; min-width:300px; }

/* Polimento visual só na aba PESQUISA */
#viewPesquisa .card h2{
  display:flex; align-items:center; gap:10px;
  font-size:20px; letter-spacing:.2px;
  margin:0 0 12px 0; padding-bottom:8px;
  border-bottom:1px solid var(--border);
}
#viewPesquisa .card{
  backdrop-filter: saturate(120%);
}
#searchList{ min-height: 48vh; max-height: 64vh; overflow:auto; }

.preview-head{
  display:flex; gap:10px; align-items:center; justify-content:space-between;
  margin: 8px 0 10px 0;
}
.preview-title{
  font-weight:700; font-size:14px; color:var(--fg);
  padding:6px 10px; border:1px solid var(--border); border-radius:10px; background:#121824;
}
.preview-actions .btn{ padding:8px 12px; border-radius:10px; }

#searchPreview{
  min-height: 72vh; /* leitura/edição prolongada */
  border: 1px solid var(--border);
  border-radius: 12px;
  background: #121824;
  padding: 16px;
  white-space: pre-wrap;
  overflow: auto;
  font-size: 14px;
  line-height: 1.6;
  letter-spacing: .1px;
}
#searchPreview.editing{
  outline:2px dashed #475569;       /* tom mais neutro */
  background:#121824;               /* fundo coerente com o tema */
}

/* realce do match */
mark{ background:#eab30833; border:1px solid #eab30855; border-radius:4px; padding:0 2px; }

/* removido suporte a “tela cheia” (não utilizado) */

/* === Criação de Documentos === */
#viewCriacao .list li{ padding:8px 10px; border:1px solid var(--border); border-radius:10px; margin-bottom:8px; cursor:pointer; background:#0f1621; }
#viewCriacao .list li.active{ outline:2px solid #60a5fa55; background:#111a27; }
#importedDocs li.active{ outline:2px solid #60a5fa55; background:#111a27; }
#viewCriacao label{ display:block; margin-bottom:4px; color:var(--acc); }
#viewCriacao input[type="text"], #viewCriacao textarea{ width:100%; }
#viewCriacao .grid-form{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
#viewCriacao .grid-form .col-span-2{ grid-column: span 2; }
#viewCriacao textarea.tall{ min-height:220px; }
#viewCriacao textarea{ min-height:120px; }

/* Ações do DRIVE (azul) e alinhamento de botões */
.btn-drive{ background:#60a5fa; color:#0b1016; }
.btn-drive.ghost{ background:#1e293b; color:#d8dee6; border:1px solid #334155; }

/* Container de ações simétrico */
.preview-actions{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }

/* Padroniza largura das views 4/8 (Pesquisa e Criação) */
@media (min-width: 920px){
  #viewCriacao .col-4{ grid-column: span 4; }
  #viewCriacao .col-8{ grid-column: span 8; }
}

/* ===== Barra do Drive no cabeçalho ===== */
#hdrDriveBar{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; margin-top:10px; }
#hdrDriveBar .btn{ padding:10px 14px; border-radius:12px; min-width:140px; }
#hdrDriveBar .btn.btn-drive{ box-shadow:0 6px 18px rgba(96,165,250,.25); }

/* ===== Polimento só da aba PESQUISA ===== */
#viewPesquisa .card{ box-shadow:0 10px 28px rgba(0,0,0,.28); }
#viewPesquisa .card h2{
  display:flex; align-items:center; justify-content:space-between;
  font-size:20px; letter-spacing:.2px; margin:0 0 12px 0; padding-bottom:8px; border-bottom:1px solid var(--border);
}
#viewPesquisa .card h2 > .row{ display:flex; flex-wrap:wrap; gap:8px; justify-content:flex-end; }
#viewPesquisa .preview-title{

  font-weight:800; font-size:15px; letter-spacing:.2px;
  padding:8px 12px; border:1px solid var(--border); border-radius:12px; background:#121824;
}
#viewPesquisa .preview-actions{ display:flex; flex-direction:row; gap:10px; align-items:center; }
#viewPesquisa .preview-actions .row .btn{ padding:10px 14px; border-radius:12px; min-width:140px; }
#viewPesquisa .preview-actions .btn.btn-drive{ background:#60a5fa; color:#0b1016; border:1px solid #334155; }

/* Botões de importação manual na esquerda: mesma largura e ritmo */
#viewPesquisa .search-toolbar .btn,
#viewPesquisa .card.sticky .row .btn{ min-width:140px; }

/* Status “bolinha” já existente – mantém */
  </style>

  <!-- PDF e DOCX -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script> if (window['pdfjsLib']) pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js'; </script>
<script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.min.js"></script>
<!-- Shell + SideNav: mesmo padrão visual do Transmissor/Workspace -->
<style id="shell-and-sidenav">
  /* Container externo (casca) */
  .app-frame{
    width:min(1920px,92vw);
    margin:24px auto;
    padding:24px 24px 28px 96px; /* espaço para o menu lateral */
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02)), var(--card);
    border:4px solid var(--border);
    border-radius:14px;
    box-shadow:0 24px 64px rgba(0,0,0,.45);
    position:relative;
  }
  /* Oculta o header original (DOM mantido p/ compatibilidade) */
  header{ display:none !important; }

  /* ===== Menu lateral (idêntico ao padrão) ===== */
  .side-nav{
    position:absolute; left:24px; top:24px; bottom:28px; z-index:10;
    width:48px; padding:6px;
    border:1px solid var(--border);
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)), var(--card);
    box-shadow:0 14px 36px rgba(0,0,0,.35);
    display:flex; flex-direction:column; align-items:center; justify-content:space-between; gap:12px;
  }

  .side-nav::after{
    content:""; position:absolute; right:-6px; top:0; bottom:0; width:1px;
    background:var(--border); border-radius:1px; opacity:.9; pointer-events:none;
  }
  .side-nav__group{ display:grid; gap:8px; justify-items:center; }
  .sn-btn{
    display:grid; place-items:center; width:40px; height:40px; margin:0 auto;
    border:1px solid var(--border); border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    color:var(--fg); text-decoration:none; cursor:pointer;
    transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease;
  }
  .sn-btn:hover{ transform:translateY(-1px); box-shadow:0 10px 24px rgba(0,0,0,.35); border-color:rgba(255,255,255,.18); }
  .sn-btn:focus{ outline:2px solid rgba(34,211,238,.25); outline-offset:2px; }
  .sn-btn.active{ background:linear-gradient(90deg,#22d3ee,#60a5fa); border-color:transparent; color:#05121a; box-shadow:0 8px 24px rgba(0,0,0,.35); }
  .sn-btn svg{ width:20px; height:20px; display:block; }
  .sn-sep{ height:1px; background:var(--border); border-radius:1px; margin:4px 0; }
  /* Dots de status na side-nav */
  .sn-dot{ width:10px; height:10px; border-radius:50%; display:block; border:1px solid var(--border); background:#9aa4b2; }
  .sn-dot.ok{ background:#16a34a; }
  .sn-dot.err{ background:#ef4444; }
  .sn-dot.idle{ background:#9aa4b2; }

  /* “Clean”: cards um pouco menos arredondados/soltos (sem mexer em cores) */
  .card{ border-radius:10px !important; padding:12px !important; box-shadow:0 12px 32px rgba(0,0,0,.32) !important; }

  /* Esconde o FAB de ajuda flutuante (vamos usar o botão da barra) */
  .help-fab{ display:none !important; }

  @media (max-width:900px){
    .side-nav{ display:none; }
    .app-frame{ padding-left:24px !important; }
  }
</style>
<!-- Fonte da assinatura (igual ao Workspace/Transmissor) -->
<link href="https://fonts.googleapis.com/css2?family=Caveat:wght@600&display=swap" rel="stylesheet">

<!-- Overrides de padrão visual + topbar + barra fixa e equalização de alturas -->
<style id="conversor-overrides">
  :root{ --grad: linear-gradient(90deg,#22d3ee,#60a5fa); }

  /* Container: expandir melhor no monitor e variação “sem menu” via classe */
  .app-frame{ width:min(1920px,96vw) !important; }
  .app-frame.no-sidenav{ padding-left:24px !important; }

  /* Side-nav: dentro do container (mesmo padrão do Transmissor/Workspace) */
  .side-nav{
    position:absolute !important;
    left:24px !important; top:24px !important; bottom:28px !important;
  }

  /* Topbar (abas + Drive + assinatura “Conversor”) */
  .topbar{
    position:sticky; top:0; z-index:5;
    display:flex; align-items:center; gap:14px; justify-content:space-between;
    margin:0 0 12px 0; padding:6px 8px 10px;
    border-bottom:1px solid var(--border);
    background:transparent;
    backdrop-filter:none;
  }

  .topbar .brand{
    font-family:'Caveat', cursive; font-size:28px; line-height:1;
    background:var(--grad); -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow: 0 2px 12px rgba(34,211,238,.18);
  }
  .topbar .tabs{ display:flex; gap:8px; align-items:center; }
  .topbar .tabs .seg{
    border-radius:14px; background:#121824; border:1px solid var(--border);
    padding:8px 12px; box-shadow: 0 6px 18px rgba(0,0,0,.25);
  }
  .topbar .tabs .seg span{ font-size:14px; font-weight:600; color:var(--muted); letter-spacing:.2px; }
  .topbar .tabs .seg.active{ border-color:#94A3B8; box-shadow: 0 8px 26px rgba(148,163,184,.22), inset 0 1px 0 rgba(255,255,255,.08); }
  .topbar .tabs .seg.active span{ color:#e6edf7; background:transparent; -webkit-background-clip:initial; -webkit-text-fill-color:initial; }
  .topbar .drive .btn{ padding:8px 12px; border-radius:10px; }

  /* Botões no padrão dos outros apps (sem mudar semântica) */
  .btn{ border:1px solid var(--border); border-radius:12px; background:var(--grad); color:#05121a; font-weight:700; }
  .btn.ghost{ background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); color:var(--fg); }
  .btn-drive{ background:#60a5fa; color:#0b1016; border:1px solid #334155; }

  /* Pesquisa: duas colunas com alturas equivalentes e preview elástico */
  #viewPesquisa .grid{ align-items:stretch; }
  #viewPesquisa .card.col-4{ max-height: calc(100vh - 180px); overflow:auto; }
  #viewPesquisa .preview-card{ display:flex; flex-direction:column; max-height: calc(100vh - 180px); }
  #searchPreview{ flex:1; min-height:0; overflow:auto; }

  /* Scrollbar (coerente com o tema, se não existir já) */
  *{ scrollbar-width:thin; scrollbar-color: rgba(255,255,255,.22) #121824; }
  ::-webkit-scrollbar{ width:10px; height:10px; }
  ::-webkit-scrollbar-track{ background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02)), #121824; border:1px solid var(--border); border-radius:12px; }
  ::-webkit-scrollbar-thumb{ background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06)); border:1px solid var(--border); border-radius:10px; background-clip: padding-box; }
  ::-webkit-scrollbar-thumb:hover{ background: linear-gradient(180deg, rgba(255,255,255,.16), rgba(255,255,255,.10)); }
</style>
</head>
<body>
<div class="app-frame">
  <!-- Side Nav – atalhos de apps + abas do Conversor + ajuda -->
  <nav class="side-nav" aria-label="Atalhos">
    <div class="side-nav__group">
      <!-- Apps -->
      <a class="sn-btn" data-app="workspace" title="Workspace" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <rect x="3" y="3" width="8" height="8" rx="2" stroke="currentColor"></rect>
          <rect x="13" y="3" width="8" height="8" rx="2" stroke="currentColor"></rect>
          <rect x="3" y="13" width="8" height="8" rx="2" stroke="currentColor"></rect>
          <rect x="13" y="13" width="8" height="8" rx="2" stroke="currentColor"></rect>
        </svg>
      </a>
      <a class="sn-btn" data-app="conversor" title="Conversor" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M4 7h8v4H4z" stroke="currentColor"></path>
          <path d="M12 13h8v4h-8z" stroke="currentColor"></path>
          <path d="M8 11v2m8-2v2" stroke="currentColor"></path>
        </svg>
      </a>
      <a class="sn-btn" data-app="transmissor" title="Transmissor" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <circle cx="12" cy="12" r="2" stroke="currentColor"></circle>
          <path d="M7 7a7 7 0 0 0 0 10" stroke="currentColor"></path>
          <path d="M17 7a7 7 0 0 1 0 10" stroke="currentColor"></path>
        </svg>
      </a>
    </div>

    <div class="sn-sep" role="separator" aria-hidden="true"></div>

    <!-- Status (mostrado apenas na aba PESQUISA) -->
    <div class="side-nav__group" id="snStatusGroup">
      <span class="sn-dot idle" id="snDriveDot"   title="Status do Drive"></span>
      <span class="sn-dot idle" id="snImportDot"  title="Status de importação"></span>
    </div>

    <div class="sn-sep" role="separator" aria-hidden="true"></div>

    <div class="side-nav__group">
      <!-- Ajuda -->
      <a class="sn-btn" data-app="ajuda" title="Ajuda" href="#">

        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M12 17v.01M9.2 9a3 3 0 1 1 5.6 1.5c-.6.4-1 .9-1 1.5V14" stroke="currentColor" stroke-linecap="round"></path>
          <circle cx="12" cy="12" r="9" stroke="currentColor"></circle>
        </svg>
      </a>
    </div>
  </nav>
  <!-- Topbar unificado (abas + Drive + assinatura) -->
  <div class="topbar" id="topbar">
    <div class="brand">Conversor Plus</div>

    <div class="tabs" id="tabsBar">
      <button class="seg" data-view="conversor"><span>Conversor</span></button>
      <button class="seg" data-view="pesquisa"><span>Pesquisa</span></button>
      <button class="seg" data-view="criacao"><span>Criação</span></button>
      <button class="seg" data-view="analise"><span>Análise</span></button>
    </div>

    <div class="drive">
      <button id="tbConnect"    class="btn btn-drive" type="button" title="Conectar ao Google Drive">Conectar</button>
      <button id="tbDisconnect" class="btn ghost"     type="button" title="Encerrar sessão">Desconectar</button>
    </div>
  </div>

  <header>
    <h1>Conversor</h1>
	<nav class="app-switcher" aria-label="Outros aplicativos">
  <button id="appSwitcherBtn" class="app-switcher__btn" type="button">HDSP CORP ▾</button>
  <div id="appSwitcherMenu" class="app-switcher__menu" role="menu">
    <a class="app-switcher__item" role="menuitem" href="https://hdspcorp.github.io/curadoriapro10/" target="_blank" rel="noopener">
      <div>
        <strong>Analisador</strong>
        <small>Importa JSON e envia os grupos para avaliação</small>
      </div>
    </a>
    <a class="app-switcher__item" role="menuitem" href="https://hdspcorp.github.io/poscuradoria/" target="_blank" rel="noopener">
      <div>
        <strong>Workspace</strong>
        <small>Visualiza, e filtra as avaliações do agente de Curadoria</small>
      </div>
    </a>
  </div>
</nav>
	<span class="note"><b>Dica Importante galera:</b> </span>
	<!-- Barra do Drive no cabeçalho (ordem: Conectar • Configurar • Desconectar) -->
<div id="hdrDriveBar" aria-label="Acesso rápido ao Google Drive">
    <button id="btnDriveConnectTop"    class="btn btn-drive" type="button" title="Conectar ao Google Drive">Conectar</button>
  <button id="btnDriveDisconnectTop" class="btn ghost"     type="button" title="Encerrar sessão">Desconectar</button>
</div>

<div class="seg-wrap" id="mainTabs" style="margin-top:12px">
  <label class="seg"><input type="radio" name="mainView" id="tabConversor" checked><span>Conversor</span></label>
  <label class="seg"><input type="radio" name="mainView" id="tabPesquisa"><span>Pesquisa</span></label>
  <label class="seg"><input type="radio" name="mainView" id="tabCriacao"><span>Criação de Documentos</span></label>
</div>
  </header>

  <main>
  <div id="viewConversor" class="grid">

      <!-- CONFIG -->
      <section class="card col-6">
       <h2>
         <span>Configuração</span>
         <div class="seg-wrap" id="outmodeTop" style="margin-left:auto">
           <label class="seg"><input type="radio" name="outmode" id="modePacks" checked><span>PACKS</span></label>
           <label class="seg"><input type="radio" name="outmode" id="modeIndividual"><span>Converter TXT 1:1</span></label>
         </div>
       </h2>

<!-- 2) Opções gerais -->
<div class="row" style="margin-top:12px">
  <!-- <label><input id="stripHtml" type="checkbox" /> Remover tags HTML de arquivos .html</label> -->
  <label><input id="preserveOrder" type="checkbox" checked />Ordem por nome</label>
  <!-- <label><input id="optimizeMd" type="checkbox" /> Otimizar para IA (Markdown + metadados)</label> -->
</div>

<!-- 3) Opções para PACKS -->
<div style="margin-top:12px">
  <label class="muted"></label>
  <div class="row">
    <div style="flex:1; min-width:200px">
      <label for="packs">Número de packs</label>
      <input id="packs" type="number" min="1" max="40" value="1" list="packsList" />
      <datalist id="packsList"></datalist>
    </div>
    <div style="flex:1; min-width:200px">
      <label for="startIndex">Iniciar numeração em</label>
      <input id="startIndex" type="number" min="1" value="1" />
    </div>
    <div style="flex:1; min-width:180px">
      <label for="ext">Extensão de saída</label>
      <select id="ext">
        <option value="txt" selected>.txt</option>
        <option value="md">.md</option>
      </select>
    </div>
  </div>

  <div style="margin-top:10px">
    <label for="sepPreset">Separador entre documentos</label>
    <div class="row">
      <select id="sepPreset" style="flex:1; min-width:220px">
        <option value="blank2">2 linhas em branco</option>
        <option value="dash">Linha horizontal (---)</option>
        <option value="hash">## FIM DO DOCUMENTO ##</option>
        <option value="none" selected>Nenhum separador</option>
      </select>
      <input id="sepCustom" type="text" placeholder="Personalizado" style="flex:2; min-width:260px" />
    </div>
    <small class="muted"></small>
  </div>
</div>

<!-- 4) Ações e Progresso -->
<div class="row" style="margin-top:14px">
  <button id="btnProcess" class="btn">Gerar</button>
  <button id="btnReset" class="btn ghost">Limpar</button>
</div>
<div style="margin-top:12px">
  <div class="bar"><div id="progress"></div></div>
  <div id="status" class="pill" style="margin-top:6px">Aguardando seleção…</div>
</div>
      </section>
	  
      <!-- ARQUIVOS -->
      <section class="card col-6">
        <h2>
          <span>Arquivos</span>
          <div class="row" style="gap:8px; margin-left:auto">
            <button id="btnPickFiles" class="btn">Selecionar arquivos</button>
            <button id="btnPickFolder" class="btn ghost">Selecionar pasta</button>
          </div>
        </h2>
        <div class="row" style="margin-top:8px">
          <span class="pill">Arquivos Suportados: .txt .md .csv .json .log .html .htm .pdf .docx</span>
        </div>
        <input id="fileInputFiles" type="file" multiple style="display:none" accept=".txt,.md,.csv,.json,.log,.html,.htm,.pdf,.docx,.doc" />
        <input id="fileInputDir" type="file" multiple style="display:none" webkitdirectory directory accept=".txt,.md,.csv,.json,.log,.html,.htm,.pdf,.docx,.doc" />
        <div id="fileList" class="list" style="margin-top:12px"></div>
        <div class="stats">
          <div class="stat"><span>Total de arquivos</span><strong id="statFiles">0</strong></div>
          <div class="stat"><span>Tamanho MB</span><strong id="statSize">0</strong></div>
          <div class="stat"><span>Qtd. Caractéres</span><strong id="statChars">0</strong></div>
          <div class="stat"><span>Tokens</span><strong id="statTokens">0</strong></div>
        </div>
      </section>

      <section class="card col-12">
        <h2>Downloads</h2>
        <div class="row" style="margin: 0 0 8px 0">
          <button id="btnDownloadAll" class="btn ghost" disabled>Baixar todos</button>
        </div>
        <div id="downloads" class="downloads"></div>
      </section>

            <section class="card col-12">
        <h2>Prévia</h2>
        <pre id="preview">(vazio)</pre>
      </section>
 	  </div><!-- /#viewConversor -->

<!-- ===== CRIAÇÃO DE DOCUMENTOS (3ª aba) ===== -->
<div id="viewCriacao" style="display:none">
  <div class="grid">
    <!-- Menu lateral de bots -->
    <aside class="card col-4">
      <h2>Bots</h2>
      <ul id="botMenu" class="list" style="list-style:none; padding-left:0; margin:0"></ul>
    </aside>

    <!-- Área do formulário dinâmico -->
    <section class="card col-8">
      <h2>Criação de Documentos</h2>

      <!-- TÍTULO do documento -->
      <div class="row" style="margin-bottom:8px">
        <input id="criaNome" type="text" placeholder="Título do documento (aparece no [NOME DO DOCUMENTO])" />
      </div>

      <!-- Form dinâmico do modelo selecionado -->
      <div id="criaArea" class="grid-form">
        <!-- O formulário do modelo selecionado é renderizado via JS.
             **ONDE ADICIONAR CAMPOS DOS OUTROS MODELOS**:
             procure por "const DOC_MODELS" no <script> e edite os arrays de cada bot. -->
      </div>

      <div class="row preview-actions" style="margin-top:12px">
        <button id="btnCriarSaveDrive" class="btn btn-drive" title="Salvar no Google Drive">Salvar no Drive</button>
        <button id="btnCriarExportDocx" class="btn ghost" title="Baixar .docx">Exportar .docx</button>
        <button id="btnCriarExportTxt" class="btn ghost" title="Baixar .txt">Exportar .txt</button>
      </div>
    </section>
  </div>
</div>

  <!-- ===== PESQUISA (nova tela) ===== -->
    <div id="viewPesquisa" style="display:none">

        <!-- (barra de Drive movida para o cabeçalho) -->

    <div class="grid">
    <!-- Coluna ESQUERDA (Resultados) -->
    <section class="card col-4 sticky">
      <h2>
        <span>Pesquisa &amp; Resultados</span>
        <div class="row" style="gap:8px">
          <!-- Lista de documentos (modal) -->
          <button id="btnDocsModalOpen" class="sn-btn" title="Documentos importados" type="button" aria-label="Documentos importados">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M4 6h16v12H4z" stroke="currentColor"></path>
              <path d="M8 9h8M8 12h8M8 15h5" stroke="currentColor"></path>
            </svg>
          </button>
          <!-- Importar arquivos (arquivo com seta para cima) -->
          <button id="btnPickFiles2" class="sn-btn" title="Importar arquivos" type="button" aria-label="Importar arquivos">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M6 4h9l3 3v13H6z" stroke="currentColor"/>
              <path d="M12 16V9M9.5 11.5 12 9l2.5 2.5" stroke="currentColor"/>
            </svg>
          </button>
          <!-- Importar pasta (pasta com seta para cima) -->
          <button id="btnPickFolder2" class="sn-btn" title="Importar pasta" type="button" aria-label="Importar pasta">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M3 7h7l2 2h9v10H3z" stroke="currentColor"/>
              <path d="M12 17v-5M10.5 13.5 12 12l1.5 1.5" stroke="currentColor"/>
            </svg>
          </button>
          <!-- STATUS de importação (muda de cor) -->
          <button id="btnImportStatus" class="sn-btn" title="Status de importação" type="button" aria-label="Status de importação" style="pointer-events:none;">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <circle cx="12" cy="12" r="6" stroke="currentColor"></circle>
            </svg>
          </button>
        </div>
      </h2>

        <div class="search-toolbar">
        <input id="searchInput" type="text" placeholder="Digite para pesquisar (dinâmico)..." style="flex:2; min-width:320px" />
        <label><input id="searchCase" type="checkbox" /> Diferenciar maiúsc./minúsc.</label>
        <label><input id="searchWhole" type="checkbox" /> Palavra inteira</label>
        <label title="Quando ligado, a busca ignora acentos (ex.: DÚVIDA = DUVIDA).">
  <input id="searchDiacritics" type="checkbox" checked /> Ignorar acentos (á = a)
</label>
      </div>

  <!-- (botões de importação movidos para o cabeçalho da seção) -->

      <div class="status-line" style="display:none">
  <span id="driveStatus"  class="pill">Drive: Desconectado</span>
  <span id="importStatus" class="pill">Origem: Nenhum documento carregado</span>
</div>

<!-- Lista de documentos agora abre em modal (id=docsModal); removida desta coluna -->

<label class="muted" style="margin-top:8px; display:block">Resultados</label>
<div id="searchList" class="list"></div>

    </section>

    <!-- Coluna DIREITA (Prévia) -->
    <section class="card col-8 preview-card">
      <h2>
        <span>Prévia &amp; Edição</span>
        <div class="preview-actions" aria-label="Ações da prévia" style="gap:10px">
          <!-- Salvar no Drive (nuvem com seta para cima) -->
          <button id="btnSaveDrive" class="sn-btn" title="Salvar no Drive" type="button" aria-label="Salvar no Drive">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M6 18h12a3 3 0 0 0 0-6 5 5 0 0 0-9.5-2.5A4 4 0 0 0 6 12" stroke="currentColor"/>
              <path d="M12 16V9M9.5 11.5 12 9l2.5 2.5" stroke="currentColor"/>
            </svg>
          </button>
          <!-- Baixar DOCX (arquivo com seta para baixo) -->
          <button id="btnExportDocx" class="sn-btn" title="Baixar DOCX" type="button" aria-label="Baixar DOCX">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M6 4h9l3 3v13H6z" stroke="currentColor"/>
              <path d="M12 9v7M9.5 13.5 12 16l2.5-2.5" stroke="currentColor"/>
            </svg>
          </button>
          <!-- Baixar TXT (arquivo listrado com seta para baixo) -->
          <button id="btnExportTxt" class="sn-btn" title="Baixar TXT" type="button" aria-label="Baixar TXT">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M5 4h9l3 3v13H5z" stroke="currentColor"/>
              <path d="M8 9h6M8 12h6M8 15h4" stroke="currentColor"/>
              <path d="M12 11v7M9.5 16.5 12 19l2.5-2.5" stroke="currentColor"/>
            </svg>
          </button>
          <!-- Editar (lápis) -->
          <button id="btnEdit" class="sn-btn" title="Editar" type="button" aria-label="Editar">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M4 20h4l10-10-4-4L4 16v4z" stroke="currentColor"/>
            </svg>
          </button>
        </div>
      </h2>
      <div class="preview-head">
        <span class="preview-title" id="docTitle">(nenhum documento selecionado)</span>
      </div>

      <label class="muted">Prévia (500 antes | 1000 depois do 1º match · clique no resultado para abrir)</label>
      <div id="searchPreview" aria-label="Prévia do documento"></div>
      <!-- Mantido oculto apenas por compatibilidade -->
      <textarea id="editArea" rows="12" style="display:none; width:100%; margin-top:10px"
        placeholder="Edite o conteúdo completo do documento aqui..."></textarea>
    </section>
  </div>

</div>

<!-- ===== ANÁLISE (4ª aba) ===== -->
<div id="viewAnalise" style="display:none">
  <div class="grid">
    <section class="card col-12">
      <h2>
        <span>Análise</span>
        <div class="row" style="gap:8px; margin-left:auto">
          <button id="btnAnImport" class="btn">Importar</button>
          <button id="btnAnDownload" class="btn ghost" disabled>Download</button>
        </div>
      </h2>

      <!-- input oculto apenas desta aba -->
      <input id="anFile" type="file" accept=".json,application/json" style="display:none" />
    </section>
  </div>
</div>

<!-- lógica exclusiva da aba Análise (não interfere no restante) -->
<script>
(function AnaliseTab(){
  const btnImp = document.getElementById('btnAnImport');
  const btnDwn = document.getElementById('btnAnDownload');
  const input  = document.getElementById('anFile');

  let csvReady = ''; // CSV gerado após importação

  function toBRDate(d){
    return d ? d.toLocaleDateString('pt-BR', { timeZone:'UTC' }) : '';
  }

  // Constrói CSV com 3 colunas: Cliente;Data;Quantidade
  function buildCsv(data){
    const convs = (data && data.conversations) ? data.conversations
                 : (Array.isArray(data) ? data : []);
    const map = new Map(); // code -> { date: Date|null, q: number }

    for (const c of convs){
      const rawId = c.user_id || (c.user && (c.user.id || c.userId)) || '';
      const code  = String(rawId||'').split('.')[0]; // apenas antes do ponto
      if (!code) continue;

      const created = c.created_at || c.createdAt || '';
      const d       = created ? new Date(created) : null;

      const msgs  = Array.isArray(c.messages) ? c.messages : [];
      const qUser = msgs.reduce((acc,m)=> acc + ((String(m.role||'').toLowerCase()==='user') ? 1 : 0), 0);

      const prev = map.get(code);
      const earliest = prev?.date ? (d && d < prev.date ? d : prev.date) : (d || null);
      const q = (prev?.q || 0) + qUser;

      map.set(code, { date: earliest, q });
    }

    const header = 'Cliente;Data;Quantidade';
    const rows   = Array.from(map.entries()).map(([code,v]) =>
      `${code};${toBRDate(v.date)};${v.q}`
    );

    return header + '\n' + rows.join('\n');
  }

  // Importar
  btnImp?.addEventListener('click', (e)=>{ e.preventDefault(); input?.click(); });
  input?.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    try{
      const text = await f.text();
      const json = JSON.parse(text);
      csvReady = buildCsv(json);
      if (btnDwn) btnDwn.disabled = !csvReady;
      alert('JSON importado. CSV pronto para download.');
    }catch(err){
      console.error(err);
      alert('Arquivo inválido ou JSON malformado: ' + (err.message||err));
    }finally{
      e.target.value = ''; // permite reimportar o mesmo arquivo
    }
  });

  // Download
  btnDwn?.addEventListener('click', (e)=>{
    e.preventDefault();
    if (!csvReady){ alert('Importe um arquivo JSON primeiro.'); return; }
    const fname = 'analise.csv';
    if (typeof window.download === 'function'){
      window.download(fname, csvReady);
    } else {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([csvReady], {type:'text/csv;charset=utf-8;'}));
      a.download = fname; a.click();
      setTimeout(()=> URL.revokeObjectURL(a.href), 600);
    }
  });
})();
</script>

  <!-- Modal de configuração do Google Drive -->
  <div id="driveCfg" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:9999; align-items:center; justify-content:center;">
    <div style="width:min(560px, 94vw); background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px;">
      <h3 style="margin:0 0 10px">Configuração do Google Drive</h3>
      <div class="row">
        <input id="cfgApiKey"    type="text"  placeholder="API KEY" style="flex:1; min-width:260px" />
        <input id="cfgClientId"  type="text"  placeholder="CLIENT ID (OAuth Web)" style="flex:1; min-width:260px" />
      </div>
      <div class="row" style="margin-top:10px">
        <input id="cfgFolderId"  type="text"  placeholder="Folder ID padrão (opcional)" style="flex:1; min-width:260px" />
      </div>
      <div class="row" style="margin-top:12px; justify-content:space-between">
    <div class="row" style="gap:8px">
    <button id="cfgConnect"    class="btn btn-drive" type="button">Conectar ao Google Drive</button>
  </div>
  <div class="row" style="gap:8px">
    <button id="cfgCancel" class="btn ghost" type="button">Cancelar</button>
    <button id="cfgSave"   class="btn"       type="button">Salvar</button>
  </div>
</div>
<small class="muted">Escopo usado: <code>drive.file</code> (criar/editar arquivos do app). Você pode trocar o Folder ID depois.</small>
    </div>
  </div>

</main>
<script>
</main>
<script>
// "Baixar DOCX/TXT": salva no Drive (se disponível) e baixa o arquivo (anti-duplo clique).
(function bindSavesWithPicker(){
  function mdRuns(line, docx){
    const { TextRun } = docx;
    const out=[]; const re=/(\*\*[^*]+\*\*|\*[^*]+\*|__[^_]+__|_[^_]+_)/g; let i=0,m;
    while((m=re.exec(line))){
      if(m.index>i) out.push(new TextRun({ text: line.slice(i,m.index), font:'Arial', size:20 }));
      const raw=m[0], inner=raw.replace(/^\*\*|\*\*$|^__|__$/g,'').replace(/^\*|\*$|^_|_$/g,'');
      const b=raw.startsWith('**')||raw.startsWith('__'); const it=(!b)&&(raw.startsWith('*')||raw.startsWith('_'));
      out.push(new TextRun({ text: inner, bold:b, italics:it, font:'Arial', size:20 })); i=re.lastIndex;
    }
    if(i<line.length) out.push(new TextRun({ text: line.slice(i), font:'Arial', size:20 }));
    return out.length ? out : [ new TextRun({ text:' ', font:'Arial', size:20 }) ];
  }

    async function saveDocxFromPreview(targetBtn){
    if(targetBtn?.dataset.busy==='1') return; targetBtn.dataset.busy='1';
    try{
      // se estiver editando, finaliza antes de salvar
      if (els?.searchPreview?.isContentEditable) {
        els.searchPreview.contentEditable = 'false';
        els.searchPreview.classList.remove('editing');
        if (els.btnEdit) { els.btnEdit.dataset.active='0'; els.btnEdit.classList.remove('active'); }
      }
      // salva no Drive se o botão existir/estiver habilitado
      if (els?.btnSaveDrive && !els.btnSaveDrive.disabled) { try{ els.btnSaveDrive.click(); }catch(_){} }

      if(!window.docx){ alert('Biblioteca DOCX não carregada.'); return; }
      const { Document, Packer, Paragraph, TextRun } = docx;
      const title = (els.docTitle?.textContent || selectedDoc?.name || 'documento').trim() || 'documento';
      const base  = title.replace(/\.[^.]+$/, '');
      const text  = String(els.searchPreview?.textContent || selectedDoc?.text || '');
      const children = [
        new Paragraph({ children:[ new TextRun({ text: title, bold:true, font:'Arial', size:28 }) ] }),
        new Paragraph({ children:[ new TextRun({ text:'', font:'Arial', size:20 }) ] }),
      ];
      text.split('\n').forEach(l=> children.push(new Paragraph({ children: mdRuns(l, docx) })));
      const docxDoc = new Document({ sections:[{ properties:{}, children }] });
      const blob = await Packer.toBlob(docxDoc);
      const suggested = `${base}.docx`;

      if ('showSaveFilePicker' in window){
        const handle = await window.showSaveFilePicker({
          suggestedName: suggested,
          types: [{ description: 'Documento do Word (.docx)', accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] } }]
        });
        const w = await handle.createWritable(); await w.write(blob); await w.close();
      } else if ('showDirectoryPicker' in window){
        const dir = await window.showDirectoryPicker({ mode:'readwrite' });
        const fh = await dir.getFileHandle(suggested, { create:true });
        const w = await fh.createWritable(); await w.write(blob); await w.close();
      } else {
        const url = URL.createObjectURL(blob);
        const a = Object.assign(document.createElement('a'), { href:url, download:suggested, style:'display:none' });
        document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
      }
    }catch(e){ console.error(e); alert('Falha ao salvar DOCX: ' + (e.message||e)); }
    finally{ delete targetBtn.dataset.busy; }
  }

    async function saveTxtFromPreview(targetBtn){
    if(targetBtn?.dataset.busy==='1') return; targetBtn.dataset.busy='1';
    try{
      // se estiver editando, finaliza antes de salvar
      if (els?.searchPreview?.isContentEditable) {
        els.searchPreview.contentEditable = 'false';
        els.searchPreview.classList.remove('editing');
        if (els.btnEdit) { els.btnEdit.dataset.active='0'; els.btnEdit.classList.remove('active'); }
      }
      // salva no Drive se o botão existir/estiver habilitado
      if (els?.btnSaveDrive && !els.btnSaveDrive.disabled) { try{ els.btnSaveDrive.click(); }catch(_){} }

      const title = (els.docTitle?.textContent || selectedDoc?.name || 'documento').replace(/\.[^.]+$/, '');
      const text  = String(els.searchPreview?.textContent || selectedDoc?.text || '');
      const blob  = new Blob([text], {type:'text/plain'});
      const suggested = `${title}.txt`;

      if ('showSaveFilePicker' in window){
        const handle = await window.showSaveFilePicker({
          suggestedName: suggested,
          types: [{ description: 'Texto (.txt)', accept: { 'text/plain': ['.txt'] } }]
        });
        const w = await handle.createWritable(); await w.write(blob); await w.close();
      } else if ('showDirectoryPicker' in window){
        const dir = await window.showDirectoryPicker({ mode:'readwrite' });
        const fh = await dir.getFileHandle(suggested, { create:true });
        const w = await fh.createWritable(); await w.write(blob); await w.close();
      } else {
        const url = URL.createObjectURL(blob);
        const a = Object.assign(document.createElement('a'), { href:url, download:suggested, style:'display:none' });
        document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
      }
    }catch(e){ console.error(e); alert('Falha ao salvar TXT: ' + (e.message||e)); }
    finally{ delete targetBtn.dataset.busy; }
  }

  // Ligar botões (clonando para remover ouvintes antigos)
  const btnDocx = document.getElementById('btnExportDocx');
  if(btnDocx){
    const c = btnDocx.cloneNode(true);
    btnDocx.replaceWith(c);
    c.addEventListener('click', (ev)=> saveDocxFromPreview(c));
  }
  const btnTxt  = document.getElementById('btnExportTxt');
  if(btnTxt){
    const c2= btnTxt.cloneNode(true);
    btnTxt.replaceWith(c2);
    c2.addEventListener('click', (ev)=> saveTxtFromPreview(c2));
  }
})();
</script>

<!-- Posiciona a side-nav alinhada ao container (fixa ao rolar) e liga o topbar -->
<script>
(function initLayoutAndTopbar(){
  const tabs  = document.getElementById('tabsBar');
  const tConnect = document.getElementById('tbConnect');
  const tDisconnect = document.getElementById('tbDisconnect');

  // Abas no topbar → reusam os rádios/DOM já existentes
  function show(name){

    const m = { conversor: 'tabConversor', pesquisa: 'tabPesquisa', criacao: 'tabCriacao', analise: null };
    const id = m[name];
    if (id){
      const radio = document.getElementById(id);
      if (radio){ radio.checked = true; radio.dispatchEvent(new Event('change',{bubbles:true})); }
    }
    // feedback visual do topbar
    document.querySelectorAll('#tabsBar .seg').forEach(btn=>{
      btn.classList.toggle('active', btn.getAttribute('data-view')===name);
    });
    // fallback: exibir painéis manualmente caso necessário
    const vc = document.getElementById('viewConversor'),
          vp = document.getElementById('viewPesquisa'),
          vr = document.getElementById('viewCriacao'),
          va = document.getElementById('viewAnalise');
    if (vc && vp && vr){
      vc.style.display = (name==='conversor') ? '' : 'none';
      vp.style.display = (name==='pesquisa')  ? '' : 'none';
      vr.style.display = (name==='criacao')   ? '' : 'none';
      if (va) va.style.display = (name==='analise') ? '' : 'none';
    }
    // exibe as "bolinhas" de status só na aba Pesquisa
    const snGroup = document.getElementById('snStatusGroup');
    if (snGroup) snGroup.style.display = (name==='pesquisa') ? 'grid' : 'none';
  }
  if (tabs){
    tabs.querySelectorAll('.seg').forEach(btn=>{
      btn.addEventListener('click', (e)=>{ e.preventDefault(); show(btn.getAttribute('data-view')); });
    });
    // estado inicial
    show('conversor');
  }

  // Drive no topbar → dispara botões nativos (mantém funcionalidades)
  tConnect?.addEventListener('click', (e)=>{ e.preventDefault(); (document.getElementById('btnDriveConnectTop')||document.getElementById('cfgConnect'))?.click(); });
  tDisconnect?.addEventListener('click', (e)=>{ e.preventDefault(); (document.getElementById('btnDriveDisconnectTop')||document.getElementById('cfgDisconnect'))?.click(); });
})();
</script>

<!-- Liga ícones de importação do cabeçalho e atualiza o indicador de importação -->
<script>
(function wireImportIcons(){
  if (window.__WIRED_IMPORT_ICONS__) return; window.__WIRED_IMPORT_ICONS__ = true;

  // clona para remover ouvintes antigos
  let btnFiles  = document.getElementById('btnPickFiles2');
  let btnFolder = document.getElementById('btnPickFolder2');
  const inFiles = document.getElementById('fileInputFiles');
  const inDir   = document.getElementById('fileInputDir');
  if (btnFiles){ const c = btnFiles.cloneNode(true); btnFiles.replaceWith(c); btnFiles = c; }
  if (btnFolder){ const c = btnFolder.cloneNode(true); btnFolder.replaceWith(c); btnFolder = c; }

  function openInput(el){ if(el && el.click) el.click(); }
  btnFiles?.addEventListener('click',  e => { e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); openInput(inFiles);  });
  btnFolder?.addEventListener('click', e => { e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); openInput(inDir);    });

  function paintStatus(has, err){
    const dot = document.getElementById('snImportDot');
    if (dot) dot.className = 'sn-dot ' + (err ? 'err' : (has ? 'ok' : 'idle'));
    const btn = document.getElementById('btnImportStatus');
    if (btn){
      if (err){ btn.style.background = 'linear-gradient(90deg,#ef4444,#f59e0b)'; btn.style.borderColor='transparent'; }
      else if (has){ btn.style.background = 'linear-gradient(90deg,#16a34a,#22c55e)'; btn.style.borderColor='transparent'; }
      else { btn.style.background = 'linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03))'; btn.style.borderColor='var(--border)'; }
    }
  }
  function refreshImportStatus(){
    const has = (window.selectedFiles && window.selectedFiles.length) ||
                (inFiles?.files?.length || 0) || (inDir?.files?.length || 0);
    paintStatus(!!has, false);
  }
  inFiles?.addEventListener('change', refreshImportStatus, { once:false });
  inDir?.addEventListener('change',   refreshImportStatus, { once:false });

  if (window.renderImportedDocs){
    const _r = window.renderImportedDocs;
    window.renderImportedDocs = function(){
      const out = _r.apply(this, arguments);
      try{ refreshImportStatus(); }catch(_){}
      return out;
    };
  }
})();
</script>

  <!-- Ajuda flutuante (canto inferior direito) -->
  <div class="help-fab">

    <span class="help-hint" tabindex="0" aria-label="Ajuda: passo a passo" role="button">?
      <div class="help-bubble" role="dialog" aria-modal="false">
        <div class="hb-title">🧠 Passo a passo da Curadoria</div>

        <div class="hb-section">
          <div class="hb-sub">1. Conversor — Preparar os Arquivos</div>
          <p>Use este programa para converter documentos da base da Kiara (como DOCX, PDF, RTF, etc.) para o formato .TXT.<br>
          Isso permite padronizar os conteúdos e facilitar o envio para o Agente de Curadoria.</p>
          <p><strong>💡 Recomendações:</strong></p>
          <ul>
            <li>Converta apenas os documentos realmente úteis para o treinamento ou avaliação.</li>
            <li>Tente agrupar informações em menos arquivos, evitando centenas de arquivos pequenos.</li>
            <li>Após a conversão, os arquivos .TXT estarão prontos para subir na Base de Dados do Agente de Curadoria.</li>
          </ul>
        </div>

        <div class="hb-section">
          <div class="hb-sub">2. Transmissor — Enviar as Interações para Avaliação</div>
          <p>Neste programa você irá transmitir as interações (perguntas e respostas da Kiara) que serão avaliadas.</p>
          <p><strong>O que você precisa informar:</strong></p>
          <ul>
            <li>ID do Bot de Curadoria (obrigatório)</li>
            <li>Chave de API (<strong>⚠️ NUNCA</strong> compartilhe essa chave com terceiros ou exponha em lugares públicos)</li>
          </ul>
          <p><strong>Como funciona:</strong></p>
          <p>Após preencher os dados e importar o JSON com as interações do dia, clique em <em>ENVIAR</em>.<br>
          O Agente de Curadoria receberá os dados e dará início automático à avaliação de cada resposta da Kiara.</p>
          <p><strong>📅 Dica:</strong> idealmente, transmita as interações do mesmo dia em que será feita a curadoria.</p>
        </div>

        <div class="hb-section">
          <div class="hb-sub">3. Workspace — Visualizar as Avaliações</div>
          <p>Depois que o Agente de Curadoria processar os dados, ele irá gerar um arquivo .JSON com as classificações de cada resposta da Kiara.</p>
          <p><strong>O que você pode fazer no Workspace:</strong></p>
          <ul>
            <li>Importar os arquivos de retorno (.JSON).</li>
            <li>Visualizar todas as avaliações feitas.</li>
            <li>Filtrar por classificação: ✅ Correta · ❌ Incorreta · ⚠️ Falta de Documentação.</li>
          </ul>
          <p>🔎 Com os filtros, você consegue revisar rapidamente onde a IA foi bem e onde precisa de ajustes na base.</p>
        </div>

        <div class="hb-flow">✅ Fluxo ideal de uso — ➡️ Conversor → Transmissor → Workspace</div>
      </div>
    </span>
  </div>

  <script>
  const els = {
  btnPickFiles: document.getElementById('btnPickFiles'),
  btnPickFolder: document.getElementById('btnPickFolder'),
  fileInputFiles: document.getElementById('fileInputFiles'),
  fileInputDir: document.getElementById('fileInputDir'),
  fileList: document.getElementById('fileList'),
  statFiles: document.getElementById('statFiles'),
  statSize: document.getElementById('statSize'),
  statChars: document.getElementById('statChars'),
  statTokens: document.getElementById('statTokens'),
  packs: document.getElementById('packs'),
  startIndex: document.getElementById('startIndex'),
  ext: document.getElementById('ext'),
  /* stripHtml: document.getElementById('stripHtml'), */   // comentado, mantido
  preserveOrder: document.getElementById('preserveOrder'),
  sepPreset: document.getElementById('sepPreset'),
  sepCustom: document.getElementById('sepCustom'),
  /* optimizeMd: document.getElementById('optimizeMd'), */ // comentado, mantido
  btnProcess: document.getElementById('btnProcess'),
  btnReset: document.getElementById('btnReset'),
  progress: document.getElementById('progress'),
  status: document.getElementById('status'),
  downloads: document.getElementById('downloads'),
  preview: document.getElementById('preview'),
  btnDownloadAll: document.getElementById('btnDownloadAll'),
  modePacks: document.getElementById('modePacks'),
  modeIndividual: document.getElementById('modeIndividual'),
  // Tabs/views
tabConversor: document.getElementById('tabConversor'),
tabPesquisa: document.getElementById('tabPesquisa'),
viewConversor: document.getElementById('viewConversor'),
viewPesquisa: document.getElementById('viewPesquisa'),
// Pesquisa
searchInput: document.getElementById('searchInput'),
searchCase: document.getElementById('searchCase'),
searchWhole: document.getElementById('searchWhole'),
searchDiacritics: document.getElementById('searchDiacritics'),
searchList: document.getElementById('searchList'),
searchPreview: document.getElementById('searchPreview'),
// (botão antigo removido da UI; mantemos a referência se existir no DOM)
btnDrive: document.getElementById('btnDrive'),
// Import na Pesquisa
btnPickFiles2: document.getElementById('btnPickFiles2'),
btnPickFolder2: document.getElementById('btnPickFolder2'),
// Preview/edição + status
docTitle: document.getElementById('docTitle'),
btnEdit: document.getElementById('btnEdit'),
btnSaveLocal: document.getElementById('btnSaveLocal'),
btnSaveDrive: document.getElementById('btnSaveDrive'),
btnExportTxt: document.getElementById('btnExportTxt'),
btnExportDocx: document.getElementById('btnExportDocx'),
editArea: document.getElementById('editArea'),
driveStatus: document.getElementById('driveStatus'),
importStatus: document.getElementById('importStatus'),
// Topbar Pesquisa (Drive)
btnDriveCfgTop: document.getElementById('btnDriveCfgTop'),
btnDriveConnectTop: document.getElementById('btnDriveConnectTop'),
btnDriveDisconnectTop: document.getElementById('btnDriveDisconnectTop'),
// Modal Drive
driveCfg: document.getElementById('driveCfg'),
cfgApiKey: document.getElementById('cfgApiKey'),
cfgClientId: document.getElementById('cfgClientId'),
cfgFolderId: document.getElementById('cfgFolderId'),
cfgSave: document.getElementById('cfgSave'),
cfgCancel: document.getElementById('cfgCancel'),
cfgConnect: document.getElementById('cfgConnect'),
cfgDisconnect: document.getElementById('cfgDisconnect'),
// --- Criação de Documentos ---
tabCriacao: document.getElementById('tabCriacao'),
viewCriacao: document.getElementById('viewCriacao'),
botMenu: document.getElementById('botMenu'),
criaNome: document.getElementById('criaNome'),
criaArea: document.getElementById('criaArea'),
btnCriarSaveDrive: document.getElementById('btnCriarSaveDrive'),
btnCriarExportDocx: document.getElementById('btnCriarExportDocx'),
btnCriarExportTxt: document.getElementById('btnCriarExportTxt'),
};
function setStatus(el, state, text){
  if(!el) return;
  el.textContent = text || el.textContent;
  el.classList.remove('status--idle','status--ok','status--err');
  el.classList.add(state ? `status--${state}` : 'status--idle');

  // Propaga o status para as "bolinhas" da side-nav
  try{
    const cls = state ? state : 'idle';
    if (el.id === 'driveStatus'){
      const d = document.getElementById('snDriveDot');
      if (d) d.className = 'sn-dot ' + cls;
    } else if (el.id === 'importStatus'){
      const i = document.getElementById('snImportDot');
      if (i) i.className = 'sn-dot ' + cls;
    }
  }catch(_){}
}

// >>> OPCIONAL: preencha para conexão em 1 clique (sem digitar no modal)
window.DRIVE_API_KEY   = window.DRIVE_API_KEY   || 'COLOQUE_SUA_API_KEY_AQUI';
window.DRIVE_CLIENT_ID = window.DRIVE_CLIENT_ID || 'COLOQUE_SEU_CLIENT_ID_AQUI';
window.DRIVE_FOLDER_ID = window.DRIVE_FOLDER_ID || ''; // defina a pasta padrão aqui (ID)

// Helper: sempre retorna credenciais válidas (prioriza globais preenchidas; senão usa localStorage)
function getDriveCreds(){
  const lsKey = localStorage.getItem('drive_api_key') || '';
  const lsCid = localStorage.getItem('drive_client_id') || '';
  const apiKey = (window.DRIVE_API_KEY && !/COLOQUE_SUA_API_KEY_AQUI/i.test(window.DRIVE_API_KEY)) ? window.DRIVE_API_KEY : lsKey;
  const clientId = (window.DRIVE_CLIENT_ID && !/COLOQUE_SEU_CLIENT_ID_AQUI/i.test(window.DRIVE_CLIENT_ID)) ? window.DRIVE_CLIENT_ID : lsCid;
  return { apiKey: (apiKey||'').trim(), clientId: (clientId||'').trim() };
}

const _credsInit = (typeof getDriveCreds==='function') ? getDriveCreds() : { apiKey: window.DRIVE_API_KEY, clientId: window.DRIVE_CLIENT_ID };
if (els.driveStatus){
  setStatus(els.driveStatus, 'idle', _credsInit.clientId ? 'Drive: API pronta para conectar' : 'Drive: Desconectado');
}

if (els.importStatus){
  setStatus(els.importStatus, 'idle', 'Origem: Nenhum documento carregado');
}
function prettyError(err){
  try{
    if (err && err.result && err.result.error){
      const er = err.result.error;
      const code = er.code || '';
      const status = er.status || '';
      const msg = er.message || JSON.stringify(er);
      return `${code} ${status} - ${msg}`;
    }
    if (err && err.error){
      return (typeof err.error === 'string') ? err.error : JSON.stringify(err.error);
    }
    return (typeof err === 'string') ? err : JSON.stringify(err);
  }catch(_){ return String(err); }
}

  (function fillPacksDatalist(){
    const dl = document.getElementById('packsList');
    for(let i=1;i<=40;i++){
      const opt = document.createElement('option');
      opt.value = String(i);
      dl.appendChild(opt);
    }
  })();

  let selectedFiles = [];
  let generatedPacksData = [];
  const ALLOWED_EXT = ['.txt','.md','.csv','.json','.log','.html','.htm','.pdf','.docx','.doc'];

  function fmtMB(bytes){ return (bytes/1024/1024).toFixed(2); }
  function approxTokens(chars){ return Math.round(chars/4); }
  function baseName(fileName){ const i = fileName.lastIndexOf('.'); return i>0 ? fileName.slice(0,i) : fileName; }
  function hasAllowedExt(name){ const lower = name.toLowerCase(); return ALLOWED_EXT.some(ext => lower.endsWith(ext)); }
  
  // ===== Pesquisa: estado =====
let indexedDocs = [];         // [{ name, text, fold, map }]
let isIndexing = false;
let searchTimer = null;
let selectedDoc = null;       // { name, text } do item clicado
let previewFull = false;      // estado do modo tela cheia
let editing = false;          // se a área de edição está ativa

// lista compacta dos documentos importados
function renderImportedDocs(){
  const ul = document.getElementById('importedDocs');
  if(!ul) return;
  ul.innerHTML = '';
  if(!selectedFiles.length){
    ul.innerHTML = '<li class="muted">(nenhum documento)</li>';
    return;
  }
  for(const f of selectedFiles){
    const li = document.createElement('li');
    li.textContent = f.name || '(sem nome)';
    li.style.cursor = 'pointer';
    li.addEventListener('click', async ()=>{
      try{
        const text = await readFileAsText(f);

        // destaque visual do item ativo
        ul.querySelectorAll('li').forEach(x => x.classList.remove('active'));
        li.classList.add('active');

        selectedDoc = { name: f.name, text, driveFileId: (window.DRIVE_FILE_MAP||{})[f.name] };
        editing = false;
        els.searchPreview.contentEditable = 'false';
        els.searchPreview.classList.remove('editing');
        els.searchPreview.textContent = text;
        els.docTitle.textContent = f.name;
        // Ao abrir, SALVAR fica desabilitado até o usuário ativar "Editar"
        if (els.btnSaveLocal) els.btnSaveLocal.disabled = true;
      }catch(e){
        alert('Falha ao abrir: ' + (e.message||e));
      }
    });
    ul.appendChild(li);
  }
}

// renderImportedDocs agora é chamado ao final de handleSelection()

// normaliza CRLF e comprime linhas em branco (igual ao conversor)
// Remove diacríticos (áàâãä → a; éê → e; ç → c, etc.)
function fold(s){
  return String(s||'').normalize('NFD').replace(/\p{M}+/gu, '');
}
// Gera também um mapa de posições: índice no texto “foldado” → índice no original
function foldWithMap(s){
  s = String(s||'');
  let norm = '', map = [];
  for(let i=0;i<s.length;i++){
    const ch = s[i];
    const f = ch.normalize('NFD').replace(/\p{M}+/gu,''); // 1:1 para PT-BR
    for(let k=0;k<f.length;k++){ norm += f[k]; map.push(i); }
  }
  return { norm, map };
}

function buildRegex(q, {caseSensitive, wholeWord}){
  const esc = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const pat = wholeWord ? `\\b${esc}\\b` : esc;
  return new RegExp(pat, caseSensitive ? 'g' : 'gi');
}
function buildRegex(q, {caseSensitive, wholeWord}){
  const esc = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const pat = wholeWord ? `\\b${esc}\\b` : esc;
  return new RegExp(pat, caseSensitive ? 'g' : 'gi');
}
// recorta 500 antes / 1000 depois do primeiro match
function sliceWithContext(text, idx, len){
  const start = Math.max(0, idx - 500);
  const end   = Math.min(text.length, idx + len + 1000);
  const left  = text.slice(start, idx);
  const mid   = text.slice(idx, idx+len);
  const right = text.slice(idx+len, end);
  const prefix = (start>0 ? '…' : '');
  const suffix = (end<text.length ? '…' : '');
  return { left, mid, right, prefix, suffix };
}

  // ===== Preservar quebras de linha ao extrair texto de HTML =====
  function htmlToTextPreserveBreaks(html){
    const doc = new DOMParser().parseFromString(html || '', 'text/html');
    const body = doc.body || doc.createElement('body');

    // <br> -> \n
    body.querySelectorAll('br').forEach(br => br.replaceWith(doc.createTextNode('\n')));

    // Elementos de bloco recebem quebras antes/depois
    const blockSel = 'p,div,li,section,article,header,footer,pre,blockquote,hr,h1,h2,h3,h4,h5,h6,table,tr,ul,ol,dd,dt,figure,figcaption';
    body.querySelectorAll(blockSel).forEach(el=>{
      el.insertAdjacentText('beforebegin','\n');
      el.insertAdjacentText('afterend','\n');
    });

    let text = body.textContent || '';

    // Normaliza \r\n -> \n
    text = text.replace(/\r\n?/g, '\n');

    // Reduz excesso de linhas em branco consecutivas para no máx. 2
    text = text.replace(/\n{3,}/g, '\n\n');

    // NÃO dar trim global
    return text.replace(/[ \t]+\n/g, '\n').replace(/[ \t]+$/,'');
  }

  // ===== Utilitários opcionais (mantidos no código, mas **não usados** porque a opção foi comentada) =====
  function slugify(s){
    return (s || '')
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g,'')
      .replace(/[^a-zA-Z0-9]+/g,'-')
      .replace(/^-+|-+$/g,'')
      .toLowerCase();
  }
  function detectTagsFromName(name){
    const tags = [];
    const n = (name || '').toLowerCase();
    if(n.includes('ngfiscal')) tags.push('NGFiscal');
    if(n.includes('ngcontabil')) tags.push('NGContabil');
    if(n.includes('ngfolha') || n.includes('hcm')) tags.push('HCM');
    if(n.includes('keevocenter') || n.includes('keevo center')) tags.push('KeevoCenter');
    return tags.length ? tags : ['documento'];
  }
  function addFrontMatter({docId, title, source, tags}){
    const created = new Date().toISOString().slice(0,10);
    const yaml =
`---
doc_id: "${docId}"
title: "${title}"
source: "${source}"
created_at: "${created}"
tags: [${tags.map(t=>`"${t}"`).join(', ')}]
---

`;
    return yaml;
  }
  function promoteSectionHeadings(raw){
    const SECTION_HINTS = [
      'introdução','quando utilizar','quando usar','como utilizar','como usar',
      'passo a passo','procedimento','processo','campos','parâmetros','parametros',
      'observações','observacoes','requisitos','perguntas e respostas','faq','exemplos',
      'conferência','conferencia','relatórios','relatorios','erros comuns','solução de problemas'
    ];
    const lines = raw.split('\n');
    return lines.map((line) => {
      const trimmed = line.trim();
      if (!trimmed || /^#{1,6}\s/.test(trimmed) || /^(-|\*|\•|\d+\.)\s/.test(trimmed) || trimmed.length > 80) {
        return line;
      }
      const lower = trimmed.toLowerCase();
      if (SECTION_HINTS.includes(lower)) return (line.startsWith('## ') ? line : `## ${trimmed}`);
      if (/:$/.test(trimmed) && trimmed.length <= 60) {
        const noColon = trimmed.replace(/:$/,'');
        return (line.startsWith('## ') ? line : `## ${noColon}`);
      }
      return line;
    }).join('\n');
  }
  function normalizeBullets(raw){
    return raw
      .replace(/^\s*[•\*]\s+/gm, '- ')
      .replace(/^\s*-\s{2,}/gm, '- ');
  }

  function ensureLf(raw){ return raw.replace(/\r\n?/g, '\n'); }
  function enforceMaxBlankLines(raw){ return raw.replace(/\n{3,}/g, '\n\n'); }
  
  /** Reverte o padrão do Drive que troca ":" por "_" quando há espaços em volta.
 * Ex.: "Notas_ Como" -> "Notas: Como"
 * Mantém underscores legítimos (sem espaços em volta). */
function restoreColons(name){
  return String(name).replace(/\s_\s/g, ': ');
}

  // Ordenação natural com prefixos numéricos
  function splitNumericPrefix(n){
    const base = n.replace(/^.*[\\/]/,'');
    const m = base.match(/^\s*(\d+(?:\.\d+)*)(?=\s|[-_.])/);
    if(!m) return null;
    return m[1].split('.').map(v=>parseInt(v,10));
  }
  function cmpByVersionedName(aName, bName){
    const aNums = splitNumericPrefix(aName);
    const bNums = splitNumericPrefix(bName);
    if(aNums && bNums){
      const len = Math.max(aNums.length, bNums.length);
      for(let i=0;i<len;i++){
        const av = (i < aNums.length) ? aNums[i] : 0;
        const bv = (i < bNums.length) ? bNums[i] : 0;
        if(av !== bv) return av - bv;
      }
      return aName.localeCompare(bName, undefined, {sensitivity:'base', numeric:true});
    }
    if(aNums) return -1;
    if(bNums) return 1;
    return aName.localeCompare(bName, undefined, {sensitivity:'base', numeric:true});
  }

  // ========= UI base =========
  els.btnPickFiles.addEventListener('click', ()=> els.fileInputFiles.click());
  els.btnPickFolder.addEventListener('click', ()=> els.fileInputDir.click());
  els.fileInputFiles.addEventListener('change', handleSelection);
  els.fileInputDir.addEventListener('change', handleSelection);

function handleSelection(){
  const files = Array.from(this.files || []);
  const filtered = files.filter(f => hasAllowedExt(f.name));
  selectedFiles = mergeFileLists(selectedFiles, filtered);
  renderFileList();
  indexedDocs = []; // força reindexar na próxima busca (Pesquisa)

  // STATUS: origem manual
  if(els.importStatus){
    const n = selectedFiles.length;
    if(n){
      setStatus(els.importStatus, 'ok', `Origem: importação manual (${n} arquivo${n>1?'s':''})`);
    } else {
      setStatus(els.importStatus, 'idle', 'Origem: Nenhum documento carregado');
    }
  }

  // Atualiza o painel "Documentos importados" imediatamente
  renderImportedDocs();
}
  function mergeFileLists(prev, add){
    const map = new Map();
    for(const f of prev){ map.set((f.webkitRelativePath||f.name)+':'+f.size, f); }
    for(const f of add){ map.set((f.webkitRelativePath||f.name)+':'+f.size, f); }
    return Array.from(map.values());
  }
  function renderFileList(){
    els.fileList.innerHTML = '';
    if(!selectedFiles.length){
      els.statFiles.textContent = '0'; els.statSize.textContent = '0'; els.statChars.textContent = '0'; els.statTokens.textContent = '0';
      els.status.textContent = 'Aguardando seleção…';
      return;
    }
    let totalSize = 0;
    const ul = document.createElement('ul'); ul.style.listStyle = 'none'; ul.style.padding = 0; ul.style.margin = 0;
    selectedFiles.sort((a,b)=> cmpByVersionedName(a.name, b.name));
    selectedFiles.forEach((f,idx)=>{ totalSize += f.size; if(idx<300){ const li=document.createElement('li'); li.textContent=(f.webkitRelativePath||f.name); ul.appendChild(li);} });
    if(selectedFiles.length>300){ const li=document.createElement('li'); li.textContent=`… (+${selectedFiles.length-300} mais)`; ul.appendChild(li);}    
    els.fileList.appendChild(ul);
    els.statFiles.textContent = String(selectedFiles.length);
    els.statSize.textContent = fmtMB(totalSize);
    els.statChars.textContent = '—';
    els.statTokens.textContent = '—';
    els.status.textContent = 'Pronto para processar';
  }

  // ========= Extractors =========
  async function extractPdfText(file){
    const arrayBuffer = await file.arrayBuffer();
    if(!window.pdfjsLib){ throw new Error('PDF.js não carregado'); }
    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
    let text = '';
    for(let p=1; p<=pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const tc = await page.getTextContent();
      const pageText = tc.items.map(i => (i.str || '')).join(' ');
      text += pageText + '\n\n';
    }
    return text;
  }
  async function extractDocxText(file){
    const arrayBuffer = await file.arrayBuffer();
    if(!window.mammoth){ throw new Error('Mammoth (DOCX) não carregado'); }
    const result = await window.mammoth.convertToHtml({arrayBuffer});
    const html = result.value || '';
    return htmlToTextPreserveBreaks(html);
  }
  async function readFileAsText(file){
    const lower = file.name.toLowerCase();
    if(lower.endsWith('.pdf')){ return await extractPdfText(file); }
    if(lower.endsWith('.docx')){ return await extractDocxText(file); }
    if(lower.endsWith('.doc')){ throw new Error('Arquivo .DOC não suportado no navegador: '+file.name+' — converta para .DOCX/.PDF/.TXT.'); }

    const raw = await file.text();

    if(/\.(html?|HTML?)$/.test(file.name)){
      /* if(els.stripHtml.checked){  // comentado
        return htmlToTextPreserveBreaks(raw);
      } else { */
        return raw;
      /* } */
    }
    return raw; // TXT/MD/CSV/JSON/LOG
  }

  // ========= Helpers =========
  function getSeparator(){
    const custom = (els.sepCustom.value || '').trim();
    if(custom) return decodeEscapes(custom);
    switch(els.sepPreset.value){
      case 'dash': return '\n\n---\n\n';
      case 'hash': return '\n\n## FIM DO DOCUMENTO ##\n\n';
      case 'none': return '';
      case 'blank2':
      default: return '\n\n';
    }
  }
  function decodeEscapes(s){ return s.replace(/\\n/g, '\n').replace(/\\t/g, '\t').replace(/\\r/g, '\r'); }
  function assignDocsToPacksSequential(docs, k){
    const lengths = docs.map(d=>d.len);
    const total = lengths.reduce((a,b)=>a+b,0);
    const target = Math.ceil(total / k);
    const packs = Array.from({length:k}, () => ({docs:[], len:0}));
    let idx = 0;
    for(const d of docs){
      if(idx < k-1 && (packs[idx].len + d.len) > target){ idx++; }
      packs[idx].docs.push(d);
      packs[idx].len += d.len;
    }
    return packs;
  }
  function download(filename, text){
    const blob = new Blob([text], {type: 'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.style.display='none';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 500);
  }
 function createDownloadLink(fname, text){
  // No modo "Converter para TXT (1:1)" remover bloco inteiro [NOME DO DOCUMENTO] ... [/NOME DO DOCUMENTO]
  // e também marcadores soltos como [INICIO DO DOCUMENTO], [CONTEUDO], etc.
  if (els?.modeIndividual?.checked){
    let s = String(text||'');
    // remove bloco de nome (com conteúdo entre as tags)
    s = s.replace(/\[\s*NOME DO DOCUMENTO\s*\][\s\S]*?\[\s*\/NOME DO DOCUMENTO\s*\]/gmi, '');
    // remove marcadores de início/fim/conteúdo quando aparecem sozinhos em linhas
    s = s.replace(/^\s*\[(INICIO DO DOCUMENTO|FIM DO DOCUMENTO|CONTEUDO|\/CONTEUDO)\]\s*$/gmi, '');
    // normaliza espaços
    s = s.replace(/\n{3,}/g, '\n\n').replace(/^\s+|\s+$/g, '');
    text = s;
  }
  const a = document.createElement('a');
  a.href = '#';
  a.textContent = fname;
  a.addEventListener('click', (ev)=>{ ev.preventDefault(); download(fname, text); });
  els.downloads.appendChild(a);
  generatedPacksData.push({ fname, text });
}

  // ========= “Baixar todos” & Reset =========
 els.btnDownloadAll.addEventListener('click', async () => {
  if(!generatedPacksData.length){ alert('Nada para baixar.'); return; }

  els.btnDownloadAll.disabled = true;
  const originalText = els.btnDownloadAll.textContent;

  try {
    if ('showDirectoryPicker' in window) {
      // Chrome/Edge: escolher pasta e salvar arquivos diretamente
      els.btnDownloadAll.textContent = 'Escolhendo pasta…';
      const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });

      els.btnDownloadAll.textContent = 'Salvando na pasta…';
      for (const p of generatedPacksData) {
        const fileHandle = await dirHandle.getFileHandle(p.fname, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(p.text);
        await writable.close();
      }
      alert('Arquivos salvos com sucesso na pasta escolhida.');
    } else {
      // Outros navegadores: baixa todos via downloads tradicionais
      els.btnDownloadAll.textContent = 'Baixando todos…';
      for (const p of generatedPacksData) {
        download(p.fname, p.text);
        await new Promise(r=>setTimeout(r, 120));
      }
    }
  } catch (err) {
    console.error(err);
    alert('Não foi possível salvar/baixar: ' + (err.message || err));
  } finally {
    els.btnDownloadAll.disabled = false;
    els.btnDownloadAll.textContent = originalText;
  }
});

  els.btnReset.addEventListener('click', ()=>{
  els.fileInputFiles.value = '';
  els.fileInputDir.value = '';
  selectedFiles = [];
  generatedPacksData = [];
  els.downloads.innerHTML = '';
  els.preview.textContent = '(vazio)';
  els.progress.style.width = '0%';
  els.btnDownloadAll.disabled = true;
  renderFileList();

  // Pesquisa: limpar painel
  indexedDocs = [];
  selectedDoc = null;
  els.searchInput.value = '';
  els.searchList.innerHTML = '';
  els.searchPreview.innerHTML = '';
  els.docTitle.textContent = '(nenhum documento selecionado)';

    // STATUS: origem
  if(els.importStatus) setStatus(els.importStatus, 'idle', 'Origem: Nenhum documento carregado');
});

  // ========= Modo de saída: habilitar/desabilitar campos =========
  function syncModeUI(){
    const individual = els.modeIndividual.checked;
    // packs-only
    els.packs.disabled    = individual;
    els.sepPreset.disabled= individual;
    els.sepCustom.disabled= individual;
    els.startIndex.disabled = individual;
    // extensão: no modo individual, forçamos .txt
    els.ext.disabled      = individual;
    if (individual) { els.ext.value = 'txt'; }
    // cosmetics
    [els.packs, els.sepPreset, els.sepCustom, els.ext, els.startIndex].forEach(el=>{
      el.closest('div')?.classList.toggle('dim', individual && (el===els.packs || el===els.sepPreset || el===els.sepCustom || el===els.startIndex));
    });
  }
  els.modePacks.addEventListener('change', syncModeUI);
  els.modeIndividual.addEventListener('change', syncModeUI);
  syncModeUI(); // default já entra em PACKS
  // —— alternância de telas
function showView(which){
  els.viewConversor.style.display = (which==='conv' ? '' : 'none');
  els.viewPesquisa.style.display  = (which==='pesq' ? '' : 'none');
  els.viewCriacao.style.display   = (which==='cri'  ? '' : 'none');
}
els.tabConversor?.addEventListener('change', ()=> showView('conv'));
els.tabPesquisa?.addEventListener('change', ()=> showView('pesq'));
els.tabCriacao?.addEventListener('change',  ()=> showView('cri'));

/* ====== CRIAÇÃO DE DOCUMENTOS ======
   Onde incluir campos dos outros modelos:
   edite o objeto DOC_MODELS abaixo (cada bot é uma lista de campos).
*/
const BOT_LIST = [
  "Modelo Padrão",
  "Fiscal","Contabil","Captura Notas","People","Keevo Center",
  "Folha","ERP","Alpha","Holos Fiscal","Holos DP","Paralegal"
];

// UM modelo pronto (os demais ficam vazios para você preencher depois)
const DOC_MODELS = {
  "Modelo Padrão": [
    { key:"objetivo",     label:"Objetivo",           type:"textarea" },
    { key:"passos",       label:"Passo a Passo",      type:"textarea", tall:true },   // maior
    { key:"caminho",      label:"Caminho do Menu",    type:"textarea" },
    { key:"resultado",    label:"Resultado Esperado", type:"textarea" },
    { key:"interacao",    label:"Interação com o usuário", type:"textarea" },
    { key:"observacoes",  label:"Observações",        type:"textarea" },
    { key:"camposTela",   label:"Campos da Tela",     type:"textarea" },
    { key:"faq",          label:"FAQ",                type:"textarea", tall:true }     // maior
  ],
  "Fiscal": [], "Contabil": [], "Captura Notas": [], "People": [], "Keevo Center": [],
  "Folha": [], "ERP": [], "Alpha": [], "Holos Fiscal": [], "Holos DP": [], "Paralegal": []
};

// Monta menu lateral de bots
function renderBotMenu(){
  if(!els.botMenu) return;
  els.botMenu.innerHTML = '';
  BOT_LIST.forEach((name, idx)=>{
    const li = document.createElement('li');
    li.textContent = name;
    if(idx===0) li.classList.add('active');
    li.addEventListener('click', ()=>{
      els.botMenu.querySelectorAll('li').forEach(x=>x.classList.remove('active'));
      li.classList.add('active');
      renderForm(name);
    });
    els.botMenu.appendChild(li);
  });
}

// Desenha o formulário com base no modelo
function renderForm(botName){
  const fields = DOC_MODELS[botName] || [];
  const a = els.criaArea;
  a.innerHTML = '';
  if(!fields.length){
    a.innerHTML = '<div class="muted">Nenhum campo definido para este bot. Edite o objeto <code>DOC_MODELS</code> no script para informar os títulos.</div>';
    return;
  }
  // Primeiro campo sempre é o título do documento (fica em cima, já existe input #criaNome)
  fields.forEach(f=>{
    const wrap = document.createElement('div');
    const id = `cr_${f.key}`;
    const lab = document.createElement('label');
    lab.htmlFor = id; lab.textContent = f.label || f.key;
    let input;
    if(f.type === 'textarea'){
      input = document.createElement('textarea');
      input.id = id;
      if(f.tall) input.classList.add('tall');
    }else{
      input = document.createElement('input');
      input.type = 'text'; input.id = id;
    }
    const cell = document.createElement('div');
    cell.className = (f.type==='textarea' && f.tall) ? 'col-span-2' : '';
    cell.appendChild(lab); cell.appendChild(input);
    a.appendChild(cell);
  });
}

function buildDocTextFromForm(){
  const lines = [];
  const title = (els.criaNome?.value || '').trim();
  if (title) lines.push(`Título: ${title}`, '');
  const inputs = els.criaArea.querySelectorAll('textarea, input[type="text"]');
  inputs.forEach(el=>{
    const label = (el.previousElementSibling?.textContent || '').trim();
    const value = (el.value || '').trim();
    if(!value) return;          // ignora campos em branco
    lines.push(`**${label}:**`); // sem "##"
    lines.push(value, '');
  });
  return lines.join('\n');
}

els.btnCriarExportTxt?.addEventListener('click', ()=>{
  if(els.btnCriarExportTxt.dataset.busy==='1') return;
  els.btnCriarExportTxt.dataset.busy='1';
  try{
    const nameBase = (els.criaNome.value || 'documento').replace(/[\\/:*?"<>|]+/g,'_');
    const text = buildDocTextFromForm();
    const blob = new Blob([text], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), { href:url, download: `${nameBase}.txt`, style:'display:none' });
    document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
  } finally {
    delete els.btnCriarExportTxt.dataset.busy;
  }
});

// Helpers globais idempotentes (não quebram se já existirem)
if(!window.buildDocStructureFromForm){
  window.buildDocStructureFromForm = function(){
    const active = els.botMenu?.querySelector('li.active');
    const bot = active ? active.textContent : 'Modelo Padrão';
    const fields = DOC_MODELS[bot] || [];
    const title = (els.criaNome?.value || '').trim();
    const items = [];
    fields.forEach(f=>{
      const v=(document.getElementById(`cr_${f.key}`)?.value || '').trim();
      if(v) items.push({label: f.label || f.key, value: v});
    });
    return { title, items };
  };
}
if(!window.mdToRunsStyled){
  window.mdToRunsStyled = function(text, docx, font, size){
    const { TextRun } = docx;
    const re = /(\*\*[^*]+\*\*|\*[^*]+\*|__[^_]+__|_[^_]+_)/g;
    const runs=[]; let last=0, m;
    while((m=re.exec(text))){
      if(m.index>last) runs.push(new TextRun({ text:text.slice(last,m.index), font, size }));
      const raw=m[0];
      const inner=raw.replace(/^\*\*|\*\*$|^__|__$/g,'').replace(/^\*|\*$|^_|_$/g,'');
      const bold = raw.startsWith('**') || raw.startsWith('__');
      const ital = (!bold) && (raw.startsWith('*') || raw.startsWith('_'));
      runs.push(new TextRun({ text: inner, bold, italics: ital, font, size }));
      last=re.lastIndex;
    }
    if(last<text.length) runs.push(new TextRun({ text:text.slice(last), font, size }));
    return runs;
  };
}

els.btnCriarExportDocx?.addEventListener('click', async ()=>{
  if(els.btnCriarExportDocx.dataset.busy==='1') return;
  els.btnCriarExportDocx.dataset.busy='1';
  try{
    if(!window.docx){ alert('Biblioteca DOCX não carregada.'); return; }
    const { Document, Packer, Paragraph, TextRun } = docx;
    const { title, items } = window.buildDocStructureFromForm();
    const children = [];

    if(title){
      children.push(new Paragraph({
        children:[ new TextRun({ text: title, bold:true, font:'Arial', size:28 }) ] // 14 pt
      }));
      children.push(new Paragraph({ children:[ new TextRun({ text:'', font:'Arial', size:20 }) ] })); // espaço
    }

    items.forEach(it=>{
      // Subtítulo (12 pt, negrito)
      children.push(new Paragraph({ children:[ new TextRun({ text: it.label, bold:true, font:'Arial', size:24 }) ] }));
      // Conteúdo (10 pt, preserva ** e * )
      const lines = it.value.split(/\r?\n/);
      lines.forEach(line=>{
        const runs = window.mdToRunsStyled(line, docx, 'Arial', 20);
        children.push(new Paragraph({ children: runs.length ? runs : [ new TextRun({ text:' ', font:'Arial', size:20 }) ] }));
      });
      // espaço após bloco
      children.push(new Paragraph({ children:[ new TextRun({ text:'', font:'Arial', size:20 }) ] }));
    });

    const doc = new Document({ sections: [{ properties:{}, children }] });
    const nameBase = ((title && title.trim()) ? title : 'documento').replace(/[\\/:*?"<>|]+/g,'_');
    const blob = await Packer.toBlob(doc);
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), { href:url, download: `${nameBase}.docx`, style:'display:none' });
    document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
  } finally {
    delete els.btnCriarExportDocx.dataset.busy;
  }
});

els.btnCriarSaveDrive?.addEventListener('click', async ()=>{
  if(els.btnCriarSaveDrive.dataset.busy==='1') return;
  els.btnCriarSaveDrive.dataset.busy='1';
  try{
    if(!window.DRIVE_API_KEY || !window.DRIVE_CLIENT_ID){
      openDriveCfg?.();
      alert('Configure API Key e Client ID.');
      return;
    }
    await ensureGapiSignedIn();
    if(!window.DRIVE_FOLDER_ID){
      openDriveCfg?.();
      alert('Informe o Folder ID para salvar no Drive.');
      return;
    }
    const baseTitle = (els.criaNome?.value || '').trim();
    const nameBase = (baseTitle ? baseTitle : 'documento').replace(/[\\/:*?"<>|]+/g,'_');
    const text = buildDocTextFromForm();
    await upsertTextFileOnDrive(`${nameBase}.txt`, text); // atualiza/cria no FOLDER configurado
    alert('Documento salvo no Google Drive.');
  }catch(e){
    console.error(e);
    alert('Falha ao salvar no Drive: ' + (e.result?.error?.message || e.message || e));
  }finally{
    delete els.btnCriarSaveDrive.dataset.busy;
  }
});

// inicializa menu e formulário
renderBotMenu();
renderForm('Modelo Padrão');

showView('conv');

/* === PESQUISA: Salvar local em .DOCX (sem Drive) — handler isolado === */
(function rewireSaveLocalDocx(){
  if(!els.btnSaveLocal) return;

  // Remove listeners antigos clonando o botão
  const oldBtn = els.btnSaveLocal;
  const newBtn = oldBtn.cloneNode(true);
  oldBtn.replaceWith(newBtn);
  els.btnSaveLocal = newBtn;

  function mdRuns(text, docx){
    const { TextRun } = docx;
    const out = [];
    const re = /(\*\*[^*]+\*\*|\*[^*]+\*|__[^_]+__|_[^_]+_)/g;
    let i=0, m;
    while((m=re.exec(text))){
      if(m.index>i) out.push(new TextRun({ text:text.slice(i,m.index), font:'Arial', size:20 }));
      const raw=m[0];
      const inner=raw.replace(/^\*\*|\*\*$|^__|__$/g,'').replace(/^\*|\*$|^_|_$/g,'');
      const bold = raw.startsWith('**')||raw.startsWith('__');
      const ital = (!bold)&&(raw.startsWith('*')||raw.startsWith('_'));
      out.push(new TextRun({ text:inner, bold, italics:ital, font:'Arial', size:20 }));
      i=re.lastIndex;
    }
    if(i<text.length) out.push(new TextRun({ text:text.slice(i), font:'Arial', size:20 }));
    return out.length ? out : [ new TextRun({ text:' ', font:'Arial', size:20 }) ];
  }

  els.btnSaveLocal.addEventListener('click', async ()=>{
    try{
      if(!window.docx){ alert('Biblioteca DOCX não carregada.'); return; }
      if(!window.selectedDoc){ alert('Selecione um documento primeiro.'); return; }

      const { Document, Packer, Paragraph, TextRun } = docx;
      const base = (selectedDoc.name || 'documento').replace(/\.[^.]+$/, '');
      const text = (window.editing ? els.searchPreview.textContent : (selectedDoc.text||''));
      const lines = String(text||'').split('\n');

      const children = [
        // Título = nome do arquivo — Arial 14 negrito
        new Paragraph({ children:[ new TextRun({ text:(selectedDoc.name||'Documento'), bold:true, font:'Arial', size:28 }) ] }),
        new Paragraph({ children:[ new TextRun({ text:'', font:'Arial', size:20 }) ] })
      ];
      // Conteúdo — Arial 10
      lines.forEach(l => children.push(new Paragraph({ children: mdRuns(l, docx) })));

      const doc = new Document({ sections:[{ properties:{}, children }] });
      const blob = await Packer.toBlob(doc);
      const url = URL.createObjectURL(blob);
      const a = Object.assign(document.createElement('a'), { href:url, download: `${base}.docx`, style:'display:none' });
      document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
    }catch(e){
      console.error(e);
      alert('Falha ao salvar localmente: ' + (e.message||e));
    }
  });
})();

/* ==================== GOOGLE DRIVE – CONECTAR, DESCONECTAR E IMPORTAR ==================== */

// Mapa “nome → fileId” (para salvar no MESMO arquivo depois)
const DRIVE_FILE_MAP = Object.create(null);

// Abre o modal de configuração (reaproveita se já existir em outro script)
if (typeof openDriveCfg !== 'function'){
  window.openDriveCfg = function(){
    if(!els.driveCfg) return;
    els.cfgApiKey.value   = (window.DRIVE_API_KEY   || '');
    els.cfgClientId.value = (window.DRIVE_CLIENT_ID || '');
    els.cfgFolderId.value = (window.DRIVE_FOLDER_ID || '');
    els.driveCfg.style.display = 'flex';
  };
}

// Salva dados do modal
els.cfgSave?.addEventListener('click', ()=>{
  window.DRIVE_API_KEY   = (els.cfgApiKey.value   || '').trim();
  window.DRIVE_CLIENT_ID = (els.cfgClientId.value || '').trim();
  window.DRIVE_FOLDER_ID = (els.cfgFolderId.value || '').trim();
  try{
    localStorage.setItem('drive_api_key',   window.DRIVE_API_KEY);
    localStorage.setItem('drive_client_id', window.DRIVE_CLIENT_ID);
    localStorage.setItem('drive_folder_id', window.DRIVE_FOLDER_ID);
  }catch(_){}
  const ok = !!window.DRIVE_CLIENT_ID;
  setStatus(els.driveStatus, ok ? 'idle' : 'err', ok ? 'Drive: API pronta para conectar' : 'Drive: faltam credenciais');
  // Importante: NÃO fechar o modal ao salvar
});

els.cfgCancel?.addEventListener('click', ()=> { if(els.driveCfg) els.driveCfg.style.display='none'; });

// Ações rápidas no topo
els.btnDriveCfgTop?.addEventListener('click', ()=> openDriveCfg?.());

// Desconectar
function driveDisconnect(){
  try{
    if (window.gapi?.client) gapi.client.setToken(null);
  }catch(_){}
  setStatus(els.driveStatus, 'idle', 'Drive: Desconectado');
}
els.cfgDisconnect?.addEventListener('click', driveDisconnect);
els.btnDriveDisconnectTop?.addEventListener('click', driveDisconnect);

// Conectar e importar
async function connectDriveAndImport(){
  try{
    const _creds = (typeof getDriveCreds==='function') ? getDriveCreds() : { apiKey: window.DRIVE_API_KEY, clientId: window.DRIVE_CLIENT_ID };
    if(!_creds.apiKey || !_creds.clientId){
      openDriveCfg?.(); alert('Preencha API KEY e CLIENT ID.'); return;
    }

    setStatus(els.driveStatus, 'idle', 'Drive: conectando…');
    const g = await ensureGapiSignedIn();
    setStatus(els.driveStatus, 'ok', 'Drive: conectado');

    // 1) Se houver Folder ID (campo do modal OU global/localStorage), importa direto
    const typedFolder = (els?.cfgFolderId?.value || '').trim();
    const folderId = typedFolder || (window.DRIVE_FOLDER_ID || '').trim();

    if (folderId){
      window.DRIVE_FOLDER_ID = folderId;
      try{ localStorage.setItem('drive_folder_id', window.DRIVE_FOLDER_ID); }catch(_){}
      await importFromDriveFolder(); // carrega os arquivos da pasta informada
      return;
    }

    // 2) Sem Folder ID → abre Picker para escolher a pasta
    await new Promise(r=>g.load('picker', r));

    const token = g.client.getToken()?.access_token || '';
    const view = new google.picker.DocsView(google.picker.ViewId.FOLDERS)
      .setIncludeFolders(true)
      .setSelectFolderEnabled(true);

    const picker = new google.picker.PickerBuilder()
      .setOAuthToken(token)
      .setDeveloperKey(_creds.apiKey || window.DRIVE_API_KEY)
      .setOrigin(window.location.origin)
      .addView(view)
      .setTitle('Selecione a pasta do Google Drive para importar')
      .setCallback(async (data)=>{
        if(data.action !== google.picker.Action.PICKED){
          setStatus(els.driveStatus, 'ok', 'Drive: conectado');
          return; // usuário cancelou, mantém modal aberto
        }
        const doc = (data.docs || []).find(d => d.type==='folder' || d.mimeType==='application/vnd.google-apps.folder');
        if(!doc){ alert('Selecione uma pasta.'); return; }

        // define Folder ID escolhido, persiste e reflete no campo
        window.DRIVE_FOLDER_ID = doc.id;
DRIVE_FOLDER_ID = doc.id; // mantém a variável local em sincronia
if(els?.cfgFolderId) els.cfgFolderId.value = doc.id;
try{ localStorage.setItem('drive_folder_id', window.DRIVE_FOLDER_ID); }catch(_){}

        // importa conteúdo da pasta escolhida
        await importFromDriveFolder();
      })
      .build();

    picker.setVisible(true);
  }catch(e){
    console.error(e);
    setStatus(els.driveStatus, 'err', 'Drive: erro ao conectar');
    alert('Não foi possível conectar ao Google Drive: ' + prettyError(e));
  }
}
els.cfgConnect?.addEventListener('click', ()=>{
  if (els?.driveCfg) els.driveCfg.style.display = 'none'; // fecha o modal antes da conexão
  connectDriveAndImport();
});
els.btnDriveConnectTop?.addEventListener('click', ()=> openDriveCfg?.());

// Baixa conteúdo como texto (DOCX/PDF/Google Docs → texto)
async function fetchDriveFileText(fileMeta){
  const g = gapi;
  const token = g.client.getToken()?.access_token || '';
  const mime = fileMeta.mimeType || '';
  // Google Docs nativo → exporta como texto
  if (mime === 'application/vnd.google-apps.document'){
    const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileMeta.id)}/export?mimeType=text/plain`;
    const resp = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
    if(!resp.ok) throw new Error('Falha ao exportar Google Docs');
    return await resp.text();
  }
  // Demais → alt=media
  const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileMeta.id)}?alt=media`;
  const resp = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
  if(!resp.ok) throw new Error('Download falhou');

  const name = (fileMeta.name || '').toLowerCase();
  if (name.endsWith('.docx')){
    const ab = await resp.arrayBuffer();
    const fake = new File([ab], fileMeta.name, { type:'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    return await extractDocxText(fake);
  } else if (name.endsWith('.pdf')){
    const ab = await resp.arrayBuffer();
    const fake = new File([ab], fileMeta.name, { type:'application/pdf' });
    return await extractPdfText(fake);
  } else {
    return await resp.text(); // .txt .md .json .log .html ...
  }
}

// Importa todos os arquivos da pasta configurada
async function importFromDriveFolder(){
  const folderId = window.DRIVE_FOLDER_ID || DRIVE_FOLDER_ID || '';
  if (!folderId){
    openDriveCfg?.(); alert('Informe o Folder ID para importar a pasta do Drive.'); return;
  }
  try{
    const g = gapi;
    const res = await g.client.drive.files.list({
      q: `'${folderId}' in parents and trashed=false`,
      fields: 'files(id,name,mimeType,modifiedTime,size,parents)',
      pageSize: 1000
    });
    const list = res.result?.files || [];
    // Aceita extensões já suportadas + Google Docs nativo
    const allowed = list.filter(f=>{
      const n = (f.name||'').toLowerCase();
      if (f.mimeType === 'application/vnd.google-apps.document') return true;
      return ALLOWED_EXT.some(ext => n.endsWith(ext));
    });

    let imported = 0;
    for (const f of allowed){
      try{
        const text = await fetchDriveFileText(f);
        if (!text) continue;
        // Google Docs nativo → força .txt na cópia local
        const name = (f.mimeType === 'application/vnd.google-apps.document' && !/\.(txt|md)$/i.test(f.name))
          ? `${f.name}.txt` : f.name;

        const fileObj = new File([new Blob([text],{type:'text/plain'})], restoreColons(name), {type:'text/plain'});
        selectedFiles = mergeFileLists(selectedFiles, [fileObj]);
        DRIVE_FILE_MAP[name] = f.id; // mapeia para salvar depois
        imported++;
      }catch(err){
        console.warn('Falha ao importar', f.name, err);
      }
    }
    renderFileList();
    renderImportedDocs();

    if (els.importStatus){
      setStatus(els.importStatus, imported ? 'ok' : 'idle',
        imported ? `Origem: Google Drive (${imported} arquivo${imported>1?'s':''})` : 'Origem: Nenhum documento carregado');
    }
  }catch(e){
    console.error(e);
    setStatus(els.importStatus, 'err', 'Origem: falha ao listar pasta do Drive');
    alert('Não foi possível listar a pasta do Drive: ' + prettyError(e));
  }
}

// ===== Normalização para indexar (corrige quebra ao "indexar") =====
function normalizeForSearch(raw){
  let t = String(raw || '');
  // normaliza quebras, NBSP e tabs
  t = t.replace(/\r\n?/g, '\n').replace(/\u00A0/g,' ').replace(/\t/g,'  ');
  // tira espaços à direita
  t = t.split('\n').map(l => l.replace(/\s+$/,'')).join('\n');
  // limita blocos de linhas em branco a no máx. 2
  const out = [];
  let blank = 0;
  for(const line of t.split('\n')){
    if(line.trim()===''){ blank++; if(blank>2) continue; } else { blank = 0; }
    out.push(line);
  }
  return out.join('\n');
}

// ===== Pesquisa: indexação leve dos arquivos selecionados =====
async function ensureSearchIndex(){
  if(indexedDocs.length || isIndexing) return;
  if(!selectedFiles.length){ els.status.textContent = 'Selecione arquivos para pesquisar.'; return; }
  isIndexing = true;
  els.status.textContent = 'Indexando para pesquisa…';
  els.progress.style.width = '3%';

  indexedDocs = [];
  let processed = 0;
  for(const file of selectedFiles){
    try{
      const raw  = await readFileAsText(file);
      const text = normalizeForSearch(raw||'');
      const { norm, map } = foldWithMap(text);
      indexedDocs.push({ name: file.name, text, fold: norm, map });
    }catch(e){
      console.warn('Falha ao indexar', file.name, e);
      setStatus(els.importStatus, 'err', 'Origem: erro ao indexar '+ (file?.name||'arquivo'));
    }
    processed++;
    if (processed % 10 === 0 || processed === selectedFiles.length) {
      const pct = 3 + Math.round((processed/selectedFiles.length)*30);
      els.progress.style.width = pct + '%';
      await new Promise(r=>setTimeout(r,0));
    }
  }
  els.status.textContent = 'Indexação pronta';
  isIndexing = false;
}

// ===== Pesquisa: renderização de resultados (dinâmica) =====
function renderSearchResults(query, opts){
  const ignoreAccents = !!opts.ignoreAccents;
  const q = ignoreAccents ? fold(query) : query;
  const re = buildRegex(q, opts);

  const frag = document.createDocumentFragment();
  let totalMatches = 0;

  indexedDocs.forEach(doc=>{
    const hay = ignoreAccents ? (doc.fold || '') : (doc.text || '');
    const mAll = [...hay.matchAll(re)];
    const count = mAll.length;
    if(!count) return;
    totalMatches += count;

    const m = mAll[0];

    // Índices no ORIGINAL (se a busca foi em “fold”)
    let first = m.index;
    let len   = m[0].length;
    if(ignoreAccents && doc.map){
      const start = doc.map[first] ?? 0;
      const end   = doc.map[first + len - 1] ?? start;
      first = start;
      len   = (end - start + 1);
    }

    const ctx = sliceWithContext(doc.text, first, len);
    const div = document.createElement('div');
    div.className='result-item';
    div.innerHTML = `
      <strong>${doc.name}</strong><br>
      <small class="muted">Ocorrências: ${count}</small>
      <div style="margin-top:6px">${ctx.prefix}${escapeHtml(ctx.left)}<mark>${escapeHtml(ctx.mid)}</mark>${escapeHtml(ctx.right)}${ctx.suffix}</div>
    `;

    div.addEventListener('click', ()=>{
      selectedDoc = { name: doc.name, text: doc.text };
      els.docTitle.textContent = doc.name;

      const left  = escapeHtml(doc.text.slice(0, first));
      const mid   = escapeHtml(doc.text.slice(first, first+len));
      const right = escapeHtml(doc.text.slice(first+len));
      els.searchPreview.innerHTML = `${left}<mark>${mid}</mark>${right}`;

      editing = false;
      els.searchPreview.contentEditable = 'false';
      els.searchPreview.classList.remove('editing');
      els.btnEdit.textContent = 'Editar';
    });

    frag.appendChild(div);
  });

  els.searchList.innerHTML = '';
  els.searchList.appendChild(frag);
  if(!totalMatches){
    els.searchList.innerHTML = '<div class="muted">Nenhum resultado encontrado.</div>';
    els.searchPreview.innerHTML = '';
  }
}

function runDynamicSearch(){
  const q = (els.searchInput?.value||'').trim();
  if(!q){
  els.searchList.innerHTML='';
  els.searchPreview.innerHTML='';
  els.docTitle.textContent = '(nenhum documento selecionado)';
  selectedDoc = null;
  return;
}
  renderSearchResults(q, {
    caseSensitive: !!els.searchCase?.checked,
    wholeWord: !!els.searchWhole?.checked,
    ignoreAccents: !!els.searchDiacritics?.checked
  });
}

function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

// ===== Pesquisa: eventos (dinâmica + atalhos + Drive stub) =====
els.searchInput?.addEventListener('input', ()=>{
  clearTimeout(searchTimer);
  searchTimer = setTimeout(async ()=>{
    await ensureSearchIndex();
    runDynamicSearch();
  }, 250);
});

// (REMOVIDO) Botão “Tela cheia” — não utilizado

// ========= Botões: Salvar, Exportar TXT, Exportar DOCX =========
async function saveLocalOriginal(){
  try{
    if(!selectedDoc){ alert('Selecione um resultado primeiro.'); return; }
    const defaultName = selectedDoc.name || 'documento.txt';
    const text = selectedDoc.text || '';

    // Preferência: sobrescrever com File System Access API (quando disponível)
    if ('showSaveFilePicker' in window){
      const handle = await window.showSaveFilePicker({
        suggestedName: defaultName,
        types: [{ description: 'Texto', accept: { 'text/plain': ['.txt','.md','.log','.csv','.json','.html'] } }]
      });
      const writable = await handle.createWritable();
      await writable.write(text);
      await writable.close();
      alert('Arquivo salvo com sucesso.');
    } else {
      // Fallback: download tradicional (o usuário escolhe a pasta)
      download(defaultName, text);
    }

    // Extra: se Drive estiver configurado, também salva no Drive automaticamente
    if (DRIVE_API_KEY && DRIVE_CLIENT_ID){
      try{
        const fname = (defaultName || 'documento').replace(/\.[^.]+$/, '') + '.txt';
        await upsertTextFileOnDrive(fname, text);
        setStatus(els.driveStatus, 'ok', 'Drive: documento atualizado');
      }catch(errDrive){
        console.warn('Falha ao salvar no Drive (após salvar local):', errDrive);
        setStatus(els.driveStatus, 'err', 'Drive: falha ao salvar automaticamente');
      }
    }
  }catch(e){
    if(e && e.name === 'AbortError') return; // usuário cancelou
    console.error(e);
    alert('Não foi possível salvar: ' + (e.message || e));
  }
}

function exportTxt(){
  if(!selectedDoc){ alert('Selecione um resultado primeiro.'); return; }

  // Se estiver em modo de edição, gravar o que está na prévia
  if (els.searchPreview && els.searchPreview.isContentEditable){
    const updated = els.searchPreview.textContent || '';
    selectedDoc.text = updated;
    const i = indexedDocs.findIndex(d => d.name === selectedDoc.name);
    if (i >= 0) indexedDocs[i].text = updated;

    // Encerrar visualmente a edição (sem alterar outras funcionalidades)
    els.searchPreview.contentEditable = 'false';
    els.searchPreview.classList.remove('editing');
    if (els.btnEdit){ els.btnEdit.classList.remove('active'); els.btnEdit.dataset.active = '0'; }
    editing = false;
  }

  const fname = (selectedDoc.name || 'documento').replace(/\.[^.]+$/, '') + '.txt';
  const text  = selectedDoc.text || '';
  download(fname, text);
}

async function exportDocx(){
  if(!selectedDoc){ alert('Selecione um resultado primeiro.'); return; }
  if(!window.docx){ alert('Biblioteca DOCX não carregada.'); return; }

  // Se estiver em modo de edição, gravar o que está na prévia
  if (els.searchPreview && els.searchPreview.isContentEditable){
    const updated = els.searchPreview.textContent || '';
    selectedDoc.text = updated;
    const i = indexedDocs.findIndex(d => d.name === selectedDoc.name);
    if (i >= 0) indexedDocs[i].text = updated;

    // Encerrar visualmente a edição
    els.searchPreview.contentEditable = 'false';
    els.searchPreview.classList.remove('editing');
    if (els.btnEdit) els.btnEdit.textContent = 'Editar';
    editing = false;
  }

  const { Document, Packer, Paragraph } = docx;
  const lines = (selectedDoc.text || '').split('\n');
  const paragraphs = lines.map(l => new Paragraph(l || ' '));

  const doc = new Document({ sections: [{ properties: {}, children: paragraphs }] });
  const blob = await Packer.toBlob(doc);
  const fname = (selectedDoc.name || 'documento').replace(/\.[^.]+$/, '') + '.docx';

  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = fname; a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 500);
}

// Liga os botões novos
els.btnSaveLocal?.addEventListener('click', saveLocalOriginal);
els.btnExportTxt?.addEventListener('click', exportTxt);
els.btnExportDocx?.addEventListener('click', exportDocx);

// Editar documento (toggle inline na PRÉVIA)
els.btnEdit?.addEventListener('click', ()=>{
  if(!selectedDoc){ alert('Selecione um resultado primeiro.'); return; }
  editing = !editing;

  if(editing){
    // Mostra o TEXTO puro (sem <mark>) e habilita edição inline
    els.searchPreview.textContent = selectedDoc.text || '';
    els.searchPreview.contentEditable = 'true';
    els.searchPreview.classList.add('editing');
    els.btnEdit.textContent = 'Editar (ativo)';
  }else{
    // Salva edição feita na prévia
    const updated = els.searchPreview.textContent || '';
    selectedDoc.text = updated;

    // Atualiza o índice de busca para refletir a edição
    const idx = indexedDocs.findIndex(d => d.name === selectedDoc.name);
    if(idx >= 0) indexedDocs[idx].text = updated;

    // Volta a visualização normal
    els.searchPreview.contentEditable = 'false';
    els.searchPreview.classList.remove('editing');
    els.btnEdit.textContent = 'Editar';
  }
});

// Exportar documento (download .txt com o nome original)
els.btnExport?.addEventListener('click', ()=>{
  if(!selectedDoc){ alert('Selecione um resultado primeiro.'); return; }
  const fname = selectedDoc.name.replace(/\.[^.]+$/, '') + '.txt';
  download(fname, selectedDoc.text);
});
// Carrega gapi client e obtém token via Google Identity Services (GIS)
async function ensureGapiSignedIn(){
  return new Promise((resolve, reject)=>{
    loadGapi(async ()=>{
      try{
        const g = window.gapi;
        await new Promise(r=>g.load('client', r));
        const { apiKey, clientId } = (typeof getDriveCreds==='function') ? getDriveCreds() : { apiKey: DRIVE_API_KEY, clientId: DRIVE_CLIENT_ID };
if(!apiKey || !clientId){ throw new Error('Credenciais do Drive ausentes (API Key/Client ID).'); }
await g.client.init({ apiKey, discoveryDocs: [DRIVE_DISCOVERY] });

// Carregar GIS
await new Promise((res, rej)=>{
  if(window.google?.accounts?.oauth2) return res();
  const s = document.createElement('script');
  s.src = 'https://accounts.google.com/gsi/client';
  s.async = true; s.onload = res; s.onerror = ()=>rej(new Error('Falha ao carregar Google Identity Services'));
  document.head.appendChild(s);
});

// Solicita token (com escopos atualizados) — usa clientId válido
const tokenClient = google.accounts.oauth2.initTokenClient({
  client_id: clientId,
  scope: DRIVE_SCOPE,
  prompt: 'consent'
});

const accessToken = await new Promise((res, rej)=>{
  tokenClient.callback = (resp) => (resp && resp.access_token) ? res(resp.access_token) : rej(resp?.error || 'Token ausente');
  tokenClient.requestAccessToken({ prompt: 'consent' });
});

        g.client.setToken({ access_token: accessToken });
        resolve(g);
      }catch(e){ reject(e); }
    });
  });
}

async function upsertTextFileOnDrive(name, content){
  const g = await ensureGapiSignedIn();

  // procura por nome (dentro do Folder, se informado)
  let q = `name = '${name.replace(/'/g, "\\'")}' and trashed = false`;
  if (window.DRIVE_FOLDER_ID) q += ` and '${window.DRIVE_FOLDER_ID}' in parents`;
  const found = await g.client.drive.files.list({ q, fields: 'files(id,name,parents)' });

  // helpers de upload multipart
  const boundary = '-------314159265358979323846';
  const delimiter = `\r\n--${boundary}\r\n`;
  const closeDelim = `\r\n--${boundary}--`;
  const mkBody = (metadata, text) =>
    delimiter + 'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
    JSON.stringify(metadata) + delimiter +
    'Content-Type: text/plain; charset=UTF-8\r\n\r\n' +
    text + closeDelim;

  if (found.result.files && found.result.files.length){
    // UPDATE — não enviar "parents" no corpo!
    const file = found.result.files[0];
    const metadata = { name, mimeType: 'text/plain' };
    const body = mkBody(metadata, content);

    // mover para a pasta se precisar, via add/removeParents
    let params = { uploadType: 'multipart' };
    if (DRIVE_FOLDER_ID && !(file.parents||[]).includes(DRIVE_FOLDER_ID)){
      const remove = (file.parents||[]).join(',');
      params = { uploadType: 'multipart', addParents: DRIVE_FOLDER_ID, ...(remove ? { removeParents: remove } : {}) };
    }

    return g.client.request({
      path: `/upload/drive/v3/files/${file.id}`,
      method: 'PATCH',
      params,
      headers: { 'Content-Type': `multipart/related; boundary=${boundary}` },
      body
    });
  } else {
    // CREATE — aqui sim definimos "parents"
    const metadata = {
      name,
      mimeType: 'text/plain',
      ...(DRIVE_FOLDER_ID ? { parents: [DRIVE_FOLDER_ID] } : {})
    };
    const body = mkBody(metadata, content);

    return g.client.request({
      path: '/upload/drive/v3/files',
      method: 'POST',
      params: { uploadType: 'multipart' },
      headers: { 'Content-Type': `multipart/related; boundary=${boundary}` },
      body
    });
  }
}

els.btnSaveDrive?.addEventListener('click', async ()=>{
  try{
    if(!selectedDoc){ alert('Selecione um resultado primeiro.'); return; }
    if(!DRIVE_API_KEY || !DRIVE_CLIENT_ID){
      alert('Configure API Key e Client ID (botão “Configurar Google API”).');
      return;
    }
    const fname = (selectedDoc.name || 'documento').replace(/\.[^.]+$/, '') + '.txt';
    await upsertTextFileOnDrive(fname, selectedDoc.text || '');
    alert('Documento salvo no Google Drive.');
  }catch(e){
    console.error(e);
    alert('Falha ao salvar no Drive: ' + (e.result?.error?.message || e.message || e));
  }
});

// Importar na aba Pesquisa reaproveitando os inputs do Conversor
els.btnPickFiles2?.addEventListener('click', ()=> els.fileInputFiles?.click());
els.btnPickFolder2?.addEventListener('click', ()=> els.fileInputDir?.click());

// Conectar ao Google Drive e abrir Picker (importa arquivos/pastas selecionados)
els.btnDrive?.addEventListener('click', async ()=>{
  const timeout = (ms,msg)=> new Promise((_,rej)=> setTimeout(()=>rej(new Error(msg)), ms));
  try{
    if(!DRIVE_API_KEY || !DRIVE_CLIENT_ID){
      openDriveCfg?.();
      setStatus(els.driveStatus, 'err', 'Drive: informe API Key e Client ID');
      return;
    }

    setStatus(els.driveStatus, 'idle', 'Drive: conectando…');
    const g = await ensureGapiSignedIn();
    setStatus(els.driveStatus, 'ok', 'Drive: conectado');

    // Carrega o módulo do Picker
    await Promise.race([
      new Promise(r=>g.load('picker', r)),
      timeout(12000,'Timeout carregando Google Picker')
    ]);

    const token = g.client.getToken()?.access_token || '';
    const view = new google.picker.DocsView(google.picker.ViewId.DOCS)
      .setIncludeFolders(true)
      .setSelectFolderEnabled(true);

    const picker = new google.picker.PickerBuilder()
      .setOAuthToken(token)
      .setDeveloperKey(DRIVE_API_KEY)
      .setOrigin(window.location.origin)
      .addView(view)
      .setTitle('Selecione arquivos / pastas')
      .setCallback(async (data)=>{
        if(data.action !== google.picker.Action.PICKED){
          // Apenas fechou o picker — mantém “Conectado”
          setStatus(els.driveStatus, 'ok', 'Drive: conectado');
          return;
        }

        try{
          setStatus(els.importStatus, 'idle', 'Origem: importando do Google Drive…');

          const docs = data.docs || [];
          let imported = 0;

                    async function importFileById(fileId){
            // Metadados para decidir export (Google Docs) ou download direto
            const meta = await g.client.drive.files.get({
              fileId, fields: 'id,name,mimeType'
            });
            const m = meta.result || {};
            let blob;

            if (m.mimeType && m.mimeType.startsWith('application/vnd.google-apps.')) {
              // Google Docs nativo: exporta como texto
              const res = await g.client.drive.files.export({
                fileId: m.id, mimeType: 'text/plain'
              });
              const txt = res.body || '';
              blob = new Blob([txt], { type: 'text/plain' });

            } else if (m.mimeType === 'application/msword') {
              // .doc (Word antigo): converte temporariamente para Google Docs e exporta texto
              const copy = await g.client.drive.files.copy({
                fileId: m.id,
                resource: { mimeType: 'application/vnd.google-apps.document', name: m.name }
              });
              try{
                const ex = await g.client.drive.files.export({
                  fileId: copy.result.id, mimeType: 'text/plain'
                });
                const txt = ex.body || '';
                blob = new Blob([txt], { type: 'text/plain' });
              } finally {
                // Tenta limpar o arquivo convertido temporário, sem falhar a importação caso dê erro
                try{ await g.client.drive.files.delete({ fileId: copy.result.id }); }catch(_){}
              }

            } else {
              // Binários (PDF, DOCX, TXT, etc.) — baixa com fetch + Bearer para preservar bytes
              const token = g.client.getToken()?.access_token || '';
              const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(m.id)}?alt=media`;
              const resp = await fetch(url, { headers: { Authorization: `Bearer ${token}` }});
              if(!resp.ok) throw new Error('Falha ao baixar arquivo do Drive');
              const ab = await resp.arrayBuffer();
              const type = m.mimeType || 'application/octet-stream';
              blob = new Blob([ab], { type });
            }

            // Filtra extensões quando NÃO for Google Doc nativo
            if(!(m.mimeType && m.mimeType.startsWith('application/vnd.google-apps.'))){
              if(!hasAllowedExt(m.name)) return; // ignora não compatíveis
            }

            const restoredName = restoreColons(m.name || 'arquivo.txt');
// Se o conteúdo veio como TEXTO (Google Docs exportado ou .DOC convertido), usar extensão .txt
const isTextExport = (m.mimeType && m.mimeType.startsWith('application/vnd.google-apps.')) || m.mimeType === 'application/msword';
const finalName = isTextExport ? (baseName(restoredName) + '.txt') : restoredName;

const file = new File([blob], finalName, { type: blob.type || 'application/octet-stream' });
selectedFiles = mergeFileLists(selectedFiles, [file]);
imported++;
          }

          for(const d of docs){
            const isFolder =
              (d.mimeType === 'application/vnd.google-apps.folder') ||
              (d.type === 'folder');

            if(isFolder){
              // Lista apenas nível imediato da pasta
              const list = await g.client.drive.files.list({
                q: `'${d.id}' in parents and trashed = false`,
                fields: 'files(id,name,mimeType)',
                pageSize: 1000
              });
              const children = list.result?.files || [];
              for(const f of children){
                if((f.mimeType && f.mimeType.startsWith('application/vnd.google-apps.')) || hasAllowedExt(f.name)){
                  await importFileById(f.id);
                }
              }
            }else{
              await importFileById(d.id);
            }
          }

          renderFileList();
          renderImportedDocs?.();
          indexedDocs = []; // força reindexar na busca

          setStatus(
            els.importStatus,
            imported ? 'ok' : 'err',
            imported ? `Origem: ${imported} documento(s) importado(s) do Drive` : 'Origem: nenhum arquivo compatível'
          );
          alert('Arquivos do Drive adicionados.');
        }catch(e){
          console.error(e);
          setStatus(els.importStatus, 'err', 'Origem: falha ao importar do Drive');
          alert('Erro ao importar do Drive: ' + (e.result?.error?.message || e.message || e));
        }
      })
      .build();

    picker.setVisible(true);

  }catch(e){
    console.error(e);
    setStatus(els.driveStatus, 'err', 'Drive: ' + (e.result?.error?.message || e.message || e));
    alert('Erro ao conectar ao Google Drive: ' + (e.result?.error?.message || e.message || e));
  }
});
// Ctrl/Cmd + K foca a busca e troca para a aba Pesquisa (se você criou tabs)
document.addEventListener('keydown', (e)=>{
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='k'){
    e.preventDefault();
    els.searchInput?.focus();
  }
});
// === Configuração do Drive (API Key, Client ID, Folder) ===
const elCfg  = document.getElementById('driveCfg');
const inKey  = document.getElementById('cfgApiKey');
const inCid  = document.getElementById('cfgClientId');
const inFld  = document.getElementById('cfgFolderId');
const btCfg  = document.getElementById('btnDriveCfg');
const btCfgS = document.getElementById('cfgSave');
const btCfgC = document.getElementById('cfgCancel');

function openDriveCfg(){
  inKey.value = DRIVE_API_KEY;
  inCid.value = DRIVE_CLIENT_ID;
  inFld.value = DRIVE_FOLDER_ID;
  elCfg.style.display = 'flex';
}
function closeDriveCfg(){ elCfg.style.display = 'none'; }

btCfg?.addEventListener('click', openDriveCfg);
btCfgC?.addEventListener('click', closeDriveCfg);
btCfgS?.addEventListener('click', ()=>{
  DRIVE_API_KEY   = inKey.value.trim();
  DRIVE_CLIENT_ID = inCid.value.trim();
  DRIVE_FOLDER_ID = inFld.value.trim();
  try{
    localStorage.setItem('drive_api_key',   DRIVE_API_KEY);
    localStorage.setItem('drive_client_id', DRIVE_CLIENT_ID);
    localStorage.setItem('drive_folder_id', DRIVE_FOLDER_ID);
  }catch(_){}
  // Importante: NÃO fechar o modal ao salvar
  alert('Configuração salva.');
});

// Botão “Conectar ao Google Drive” — também importa da pasta configurada
els.btnDrive?.addEventListener('click', async ()=>{
  try{
    if(!DRIVE_API_KEY || !DRIVE_CLIENT_ID){
      openDriveCfg?.();
      setStatus(els.driveStatus, 'err', 'Drive: informe API Key e Client ID');
      return;
    }
    setStatus(els.driveStatus, 'idle', 'Drive: conectando…');
    const g = await ensureGapiSignedIn();
    setStatus(els.driveStatus, 'ok', 'Drive: conectado');

    if(!DRIVE_FOLDER_ID){
      setStatus(els.importStatus, 'err', 'Origem: defina um Folder ID na configuração');
      openDriveCfg?.();
      return;
    }

    setStatus(els.importStatus, 'idle', 'Origem: consultando pasta do Drive…');
    const list = await g.client.drive.files.list({
      q: `'${folderId}' in parents and trashed=false`,
      fields: 'files(id,name,mimeType)',
      pageSize: 1000
    });

    const all = (list.result?.files || []).filter(f => hasAllowedExt(f.name));
    if(!all.length){
      setStatus(els.importStatus, 'err', 'Origem: nenhum arquivo compatível na pasta');
      return;
    }

    let ok = 0;
    for(const f of all){
      try{
        const resp = await g.client.drive.files.get({ fileId: f.id, alt: 'media' });
        const text = typeof resp.body === 'string' ? resp.body : (resp.result || '');
        const file = new File([text], f.name, { type: 'text/plain' });
        selectedFiles.push(file);
        ok++;
      }catch(e){
        console.warn('Falha ao baixar do Drive:', f.name, e);
      }
    }
    renderImportedDocs();
    setStatus(els.importStatus, ok ? 'ok' : 'err',
      ok ? `Origem: ${ok} documento(s) importado(s) do Drive` : 'Origem: falha ao importar arquivos');
  }catch(e){
    console.error(e);
    setStatus(els.driveStatus, 'err', 'Drive: ' + prettyError(e));
  }
});

// Botão “Conectar ao Google Drive (beta)” — com feedback e erros tratados
els.btnDrive?.addEventListener('click', async ()=>{
  const timeout = (ms,msg)=> new Promise((_,rej)=> setTimeout(()=>rej(new Error(msg)), ms));
  try{
    if(!DRIVE_API_KEY || !DRIVE_CLIENT_ID){
      openDriveCfg?.();
      setStatus(els.driveStatus, 'idle', 'Drive: informe API Key e Client ID');
      return;
    }

    setStatus(els.driveStatus, 'idle', 'Drive: carregando Google APIs…');
    await new Promise((res,rej)=>{ try{ loadGapi(res); } catch(e){ rej(e); } });

    // Autentica via GIS e prepara gapi client
    setStatus(els.driveStatus, 'idle', 'Drive: autenticando…');
    const g = await ensureGapiSignedIn();

    // Carrega Picker
    setStatus(els.driveStatus, 'idle', 'Drive: abrindo seletor…');
    await Promise.race([
      new Promise(r=>g.load('picker', r)),
      timeout(12000,'Timeout carregando picker')
    ]);

    const token = g.client.getToken()?.access_token || '';
    const view = new google.picker.DocsView(google.picker.ViewId.DOCS)
      .setIncludeFolders(true)
      .setSelectFolderEnabled(true);

    const picker = new google.picker.PickerBuilder()
      .setOAuthToken(token)
      .setDeveloperKey(DRIVE_API_KEY)
      .setOrigin(window.location.origin)
      .addView(view)
      .setTitle('Selecione arquivos / pastas')
      .setCallback(async (data)=>{
        if(data.action !== google.picker.Action.PICKED){
          setStatus(els.driveStatus, 'ok', 'Drive: Conectado');
          return;
        }

        const files = data.docs || [];
        for(const f of files){
          try{
            const meta = await g.client.drive.files.get({ fileId: f.id, fields: 'id,name,mimeType' });
            const m = meta.result;

            let blob;
            if(m.mimeType.startsWith('application/vnd.google-apps.')){
              const res = await g.client.drive.files.export({ fileId: m.id, mimeType: 'text/plain' });
              const txt = res.body || '';
              blob = new Blob([txt], { type: 'text/plain' });
            }else{
              const res = await g.client.drive.files.get({ fileId: m.id, alt: 'media' });
              const b = res.body;
              blob = new Blob([b]);
            }

            const file = new File([blob], m.name, { type: blob.type || 'application/octet-stream' });
            selectedFiles = mergeFileLists(selectedFiles, [file]);
          }catch(e){ console.warn('Drive get error', e); }
        }

        renderFileList();
        indexedDocs = []; // força reindexar
                if(els.importStatus){
          const n = selectedFiles.length;
          setStatus(els.importStatus, 'ok', `Origem: Google Drive (${n} arquivo${n>1?'s':''})`);
        }
        setStatus(els.driveStatus, 'ok', 'Drive: Conectado');
        alert('Arquivos do Drive adicionados.');
      })
      .build();

    picker.setVisible(true);

  }catch(e){
    console.error(e);
    setStatus(els.driveStatus, 'err', 'Drive: erro ao conectar');
    alert('Erro ao conectar ao Google Drive: ' + prettyError(e));
  }
});

  // ========= PROCESSAR =========
  els.btnProcess.addEventListener('click', async () => {
    if(!selectedFiles.length){ alert('Selecione arquivos ou uma pasta.'); return; }
    const individual = els.modeIndividual.checked;
    const k = Math.max(1, Math.min(40, parseInt(els.packs.value,10) || 1));
    const startAt = Math.max(1, parseInt(els.startIndex.value,10) || 1);

    els.status.textContent = 'Lendo arquivos…';
    els.progress.style.width = '3%';
    generatedPacksData = [];

    const docs = [];
    let processed = 0, charTotal = 0, errors=[];

    for(const file of selectedFiles){
      try{
        let contentRaw = await readFileAsText(file);

        // SEM trim global — preserva quebras/ espaços originais
        let content = contentRaw || '';
        content = ensureLf(content);
        content = enforceMaxBlankLines(content);

        const base = baseName(file.name);
const title = restoreColons(base);
const h1 = `# ${title}`;

        /* if (els.optimizeMd?.checked) { // comentado
          let md = content;
          md = normalizeBullets(md);
          md = promoteSectionHeadings(md);
          const docId = slugify(base);
          const tags = detectTagsFromName(base);
          const yaml = addFrontMatter({docId, title, source:file.name, tags});
          content = `${yaml}${h1}\n\n${md}`;
        } else { */
          // Envolver no formato de PACK com tags legíveis pelo GPT
const body = String(content).replace(/^\n+/, ''); // remove linhas vazias iniciais, se houver
content =
`[INICIO DO DOCUMENTO]
[NOME DO DOCUMENTO] ${h1} [/NOME DO DOCUMENTO]
[CONTEUDO]
${body}
[/CONTEUDO]
[FIM DO DOCUMENTO]

`;
        /* } */

        const len = content.length; 
        charTotal += len;
        docs.push({ name:file.name, content, len });
      }catch(e){ errors.push(`${file.name}: ${e.message}`); }
      processed++;
      if (processed % 10 === 0 || processed === selectedFiles.length) {
        const pctRead = Math.round((processed / selectedFiles.length) * 70); // 0–70%
        els.progress.style.width = pctRead + '%';
        els.status.textContent = `Lendo arquivos… (${processed}/${selectedFiles.length})`;
        await new Promise(r=>setTimeout(r, 0));
      }
    }

    els.statChars.textContent = String(charTotal);
    els.statTokens.textContent = String(approxTokens(charTotal));

    if(els.preserveOrder.checked){
      docs.sort((a,b)=> cmpByVersionedName(a.name, b.name));
    }

    // ========== MODO INDIVIDUAL (.txt para cada arquivo) ==========
    if (individual) {
      els.status.textContent = 'Gerando arquivos individuais…';
      els.progress.style.width = '85%';

      els.downloads.innerHTML = '';
      let firstPreview = '';
      const ext = 'txt'; // fixo no individual

const baseProgress = 70;
docs.forEach((d, i) => {
  const text = d.content;
// restaura ":" de nomes vindos do Drive (apenas quando era " _ ")
const rawBase = d.name.replace(/\.[^.]+$/, '');
const fixedBase = restoreColons(rawBase);
const fname = fixedBase + '.' + ext;
createDownloadLink(fname, text);

        const pct = baseProgress + Math.round(((i+1) / docs.length) * 30);
        els.progress.style.width = pct + '%';

        if (i===0) {
          firstPreview = text.slice(0, 3000) + (text.length>3000 ? '\n… (cortado)' : '');
        }
      });

      els.btnDownloadAll.disabled = generatedPacksData.length === 0;
      els.preview.textContent = firstPreview || '(vazio)';
      els.progress.style.width = '100%';
      els.status.textContent = `Pronto! ${docs.length} arquivos convertidos.`;

      if(errors.length){
        const pre = document.createElement('pre');
        pre.textContent = 'Arquivos com erro (considere converter .DOC para .DOCX/PDF):\n' + errors.join('\n');
        els.downloads.appendChild(pre);
      }
      return; // encerra aqui no modo individual
    }

    // ========== MODO PACKS ==========
    els.status.textContent = 'Distribuindo documentos…';
    els.progress.style.width = '70%';

    const packs = assignDocsToPacksSequential(docs, k);

    els.downloads.innerHTML = '';
    const forceMd = false; // opção “Otimizar para IA” removida da UI
    const ext = forceMd ? 'md' : els.ext.value;
    const sep = forceMd ? '\n\n---\n\n' : getSeparator();

    let firstPreview = '';

    const baseProgress = 70;
    packs.forEach((pk, i) => {
      const header = "";
      const text = pk.docs.map(d=>d.content).join(sep);
      const num = String(startAt + i).padStart(2,'0'); // inicia a partir de X
      const fname = `base_de_dados_${num}.${ext}`;
      createDownloadLink(fname, text);

      const pct = baseProgress + Math.round(((i+1) / packs.length) * 30);
      els.progress.style.width = pct + '%';

      if(i===0){
        firstPreview = text.slice(0, 3000) + (text.length>3000 ? '\n… (cortado)' : '');
      }
    });

    els.btnDownloadAll.disabled = generatedPacksData.length === 0;
    els.preview.textContent = firstPreview || '(vazio)';
    els.progress.style.width = '100%';
    els.status.textContent = `Pronto! ${packs.length} packs gerados.`;

    if(errors.length){
      const pre = document.createElement('pre');
      pre.textContent = 'Arquivos com erro (considere converter .DOC para .DOCX/PDF):\n' + errors.join('\n');
      els.downloads.appendChild(pre);
    }
  });
  </script>
  <!-- Google API (Drive + Picker) — carrega sob demanda -->
<script>
  let DRIVE_API_KEY   = localStorage.getItem('drive_api_key')   || '';
  let DRIVE_CLIENT_ID = localStorage.getItem('drive_client_id') || '';
  let DRIVE_FOLDER_ID = localStorage.getItem('drive_folder_id') || '';
  const DRIVE_SCOPE   = 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.file';
  const DRIVE_DISCOVERY = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';

  let gapiLoading = null;
function loadGapi(callback){
  if (window.gapi) { callback(); return; }
  if (gapiLoading) { gapiLoading.then(callback); return; }

  gapiLoading = new Promise((resolve, reject)=>{
    const s = document.createElement('script');
    s.src = 'https://apis.google.com/js/api.js';
    s.onload = resolve;
    s.onerror = ()=> reject(new Error('Falha ao carregar gapi (api.js)'));
    document.head.appendChild(s);
  });

  gapiLoading.then(callback).catch((e)=>{
    console.error(e);
    alert('Google API não carregou: ' + (e.message || e));
  });
}
</script>
  <script>
(function(){
  const wrap  = document.querySelector('.app-switcher');
  const btn   = document.getElementById('appSwitcherBtn');
  const menu  = document.getElementById('appSwitcherMenu');

  if (!wrap || !btn || !menu) return;

  function toggle(open){
    wrap.classList.toggle('open', open ?? !wrap.classList.contains('open'));
  }

  btn.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(); });

  document.addEventListener('click', (e)=>{
    if (!wrap.contains(e.target)) toggle(false);
  });
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape') toggle(false);
  });
})();
</script>

<script>
  (function(){
    const hint = document.querySelector('.help-hint');
    if(!hint) return;
    document.addEventListener('click', (e)=>{
      if(!hint.contains(e.target)){
        // remove o foco do ícone, ocultando o pop-up (por CSS)
        hint.blur?.();
      }
    });
  })();
</script>
<script>
(function(){
  // ——— elementos da aba Criação ———
  const els = {
    tabCriacao: document.getElementById('tabCriacao'),
    viewCriacao: document.getElementById('viewCriacao'),
    botMenu: document.getElementById('botMenu'),
    criaNome: document.getElementById('criaNome'),
    criaArea: document.getElementById('criaArea'),
    btnCriarSaveDrive: document.getElementById('btnCriarSaveDrive'),
    btnCriarExportDocx: document.getElementById('btnCriarExportDocx'),
    btnCriarExportTxt: document.getElementById('btnCriarExportTxt'),
    // outras views (para alternância)
    viewConversor: document.getElementById('viewConversor'),
    viewPesquisa: document.getElementById('viewPesquisa'),
    tabConversor: document.getElementById('tabConversor'),
    tabPesquisa: document.getElementById('tabPesquisa')
  };

  // Se a aba não existir neste arquivo, não faz nada
  if(!els.viewCriacao) return;

  // ——— lista de bots e 1 modelo pronto ———
  const BOT_LIST = [
    "Modelo Padrão",
    "Fiscal","Contabil","Captura Notas","People","Keevo Center",
    "Folha","ERP","Alpha","Holos Fiscal","Holos DP","Paralegal"
  ];

  const DOC_MODELS = {
    "Modelo Padrão": [
      { key:"objetivo",     label:"Objetivo",                 type:"textarea" },
      { key:"interacao",    label:"Interação com o usuário",  type:"textarea" },
      { key:"caminho",      label:"Caminho do Menu",          type:"textarea" },
      { key:"camposTela",   label:"Campos da Tela",           type:"textarea" },
      { key:"passos",       label:"Passo a Passo",            type:"textarea", tall:true },
      { key:"resultado",    label:"Resultado Esperado",       type:"textarea" },
      { key:"observacoes",  label:"Observações",              type:"textarea" },
      { key:"faq",          label:"FAQ",                      type:"textarea", tall:true }
    ],
    "Fiscal": [], "Contabil": [], "Captura Notas": [], "People": [], "Keevo Center": [],
    "Folha": [], "ERP": [], "Alpha": [], "Holos Fiscal": [], "Holos DP": [], "Paralegal": []
  };

  // ——— helpers ———
  function renderBotMenu(){
    els.botMenu.innerHTML = '';
    BOT_LIST.forEach((name, idx)=>{
      const li = document.createElement('li');
      li.textContent = name;
      if(idx===0) li.classList.add('active');
      li.addEventListener('click', ()=>{
        els.botMenu.querySelectorAll('li').forEach(x=>x.classList.remove('active'));
        li.classList.add('active');
        renderForm(name);
      });
      els.botMenu.appendChild(li);
    });
  }

  function renderForm(botName){
    const fields = DOC_MODELS[botName] || [];
    els.criaArea.innerHTML = '';
    if(!fields.length){
      els.criaArea.innerHTML = '<div class="muted">Nenhum campo definido para este bot. Edite o objeto <code>DOC_MODELS</code> para informar os títulos.</div>';
      return;
    }
    fields.forEach(f=>{
      const cell = document.createElement('div');
      if(f.type==='textarea' && f.tall) cell.className = 'col-span-2';
      const lab = document.createElement('label');
      lab.textContent = f.label || f.key;
      let input;
      if(f.type==='textarea'){ input = document.createElement('textarea'); if(f.tall) input.classList.add('tall'); }
      else { input = document.createElement('input'); input.type='text'; }
      input.id = `cr_${f.key}`;
      cell.appendChild(lab); cell.appendChild(input);
      els.criaArea.appendChild(cell);
    });
  }

  // Monta texto final: ignora campos vazios; sem "##"; preserva **negrito**/*itálico* no conteúdo
  function buildDocTextFromForm(){
    const lines = [];
    const title = (els.criaNome?.value || '').trim();
    if (title) lines.push(`Título: ${title}`, '');
    const inputs = els.criaArea.querySelectorAll('textarea, input[type="text"]');
    inputs.forEach(el=>{
      const label = (el.previousElementSibling?.textContent || '').trim();
      const value = (el.value || '').trim();
      if(!value) return;
      lines.push(`**${label}:**`);
      lines.push(value, '');
    });
    return lines.join('\n');
  }

  // Parser simples de **negrito**/*itálico* para DOCX
  function mdToRuns(text, docx){
    const { TextRun } = docx;
    const tokens = [];
    const re = /(\*\*[^*]+\*\*|\*[^*]+\*|__[^_]+__|_[^_]+_)/g;
    let last = 0, m;
    while((m = re.exec(text))){
      if(m.index > last) tokens.push({t: text.slice(last, m.index)});
      const raw = m[0];
      const inner = raw.replace(/^\*\*|\*\*$|^__|__$/g,'').replace(/^\*|\*$|^_|_$/g,'');
      const isBold = raw.startsWith('**') || raw.startsWith('__');
      const isIt  = (!isBold) && (raw.startsWith('*') || raw.startsWith('_'));
      tokens.push({t: inner, b: isBold, i: isIt});
      last = re.lastIndex;
    }
    if(last < text.length) tokens.push({t: text.slice(last)});
    return tokens.map(k => new TextRun({ text: k.t, bold: !!k.b, italics: !!k.i }));
  }

  // Ações: exportar TXT/DOCX
els.btnCriarExportTxt?.addEventListener('click', ()=>{
  if(els.btnCriarExportTxt.dataset.busy==='1') return;
  els.btnCriarExportTxt.dataset.busy='1';
  try{
    const nameBase = (els.criaNome?.value || 'documento').replace(/[\\/:*?"<>|]+/g,'_');
    const text = buildDocTextFromForm();
    const blob = new Blob([text], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), { href:url, download: `${nameBase}.txt`, style:'display:none' });
    document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
  } finally {
    delete els.btnCriarExportTxt.dataset.busy;
  }
});

  if(!window.buildDocStructureFromForm){ window.buildDocStructureFromForm = function(){
  const active = els.botMenu?.querySelector('li.active');
  const bot = active ? active.textContent : 'Modelo Padrão';
  const fields = DOC_MODELS[bot] || [];
  const title = (els.criaNome?.value || '').trim();
  const items = [];
  fields.forEach(f=>{
    const v=(document.getElementById(`cr_${f.key}`)?.value || '').trim();
    if(v) items.push({label: f.label || f.key, value: v});
  });
  return { title, items };
};}
if(!window.mdToRunsStyled){ window.mdToRunsStyled = function(text, docx, font, size){
  const { TextRun } = docx; const re=/(\*\*[^*]+\*\*|\*[^*]+\*|__[^_]+__|_[^_]+_)/g;
  const runs=[]; let last=0, m;
  while((m=re.exec(text))){
    if(m.index>last) runs.push(new TextRun({ text:text.slice(last,m.index), font, size }));
    const raw=m[0]; const inner=raw.replace(/^\*\*|\*\*$|^__|__$/g,'').replace(/^\*|\*$|^_|_$/g,'');
    const bold=raw.startsWith('**')||raw.startsWith('__'); const ital=(!bold)&&(raw.startsWith('*')||raw.startsWith('_'));
    runs.push(new TextRun({ text: inner, bold, italics: ital, font, size }));
    last=re.lastIndex;
  }
  if(last<text.length) runs.push(new TextRun({ text:text.slice(last), font, size }));
  return runs;
};}

els.btnCriarExportDocx?.addEventListener('click', async ()=>{
  if(els.btnCriarExportDocx.dataset.busy==='1') return;
  els.btnCriarExportDocx.dataset.busy='1';
  try{
    if(!window.docx){ alert('Biblioteca DOCX não carregada.'); return; }
    const { Document, Packer, Paragraph, TextRun } = docx;
    const { title, items } = window.buildDocStructureFromForm();
    const children=[];
    if(title){
      children.push(new Paragraph({ children:[ new TextRun({ text:title, bold:true, font:'Arial', size:28 }) ] }));
      children.push(new Paragraph({ children:[ new TextRun({ text:'', font:'Arial', size:20 }) ] }));
    }
    items.forEach(it=>{
      children.push(new Paragraph({ children:[ new TextRun({ text:it.label, bold:true, font:'Arial', size:24 }) ] }));
      it.value.split(/\r?\n/).forEach(line=>{
        const runs = window.mdToRunsStyled(line, docx, 'Arial', 20);
        children.push(new Paragraph({ children: runs.length ? runs : [ new TextRun({ text:' ', font:'Arial', size:20 }) ] }));
      });
      children.push(new Paragraph({ children:[ new TextRun({ text:'', font:'Arial', size:20 }) ] }));
    });
    const doc = new Document({ sections:[{ properties:{}, children }] });
    const nameBase = ((title && title.trim()) ? title : 'documento').replace(/[\\/:*?"<>|]+/g,'_');
    const blob = await Packer.toBlob(doc);
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), { href:url, download: `${nameBase}.docx`, style:'display:none' });
    document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
  } finally {
    delete els.btnCriarExportDocx.dataset.busy;
  }
});

  // Salvar no Drive (opcional): usa a função existente do seu projeto, se houver
  els.btnCriarSaveDrive?.addEventListener('click', async ()=>{
    const nameBase = (els.criaNome?.value || 'documento').replace(/[\\/:*?"<>|]+/g,'_');
    const text = buildDocTextFromForm();
    if (typeof window.upsertTextFileOnDrive !== 'function'){
      alert('Função de Drive não disponível neste arquivo. (upsertTextFileOnDrive ausente)');
      return;
    }
    try{
      await window.upsertTextFileOnDrive(`${nameBase}.txt`, text);
      alert('Documento salvo no Google Drive.');
    }catch(e){
      console.error(e);
      alert('Falha ao salvar no Drive: ' + (e?.message || e));
    }
  });

  // Alternância das 3 abas (sem interferir no código existente)
  function showCriacao(which){
    if(!els.viewConversor || !els.viewPesquisa || !els.viewCriacao) return;
    els.viewConversor.style.display = (which==='conv' ? '' : 'none');
    els.viewPesquisa.style.display  = (which==='pesq' ? '' : 'none');
    els.viewCriacao.style.display   = (which==='cri'  ? '' : 'none');
  }
  els.tabConversor?.addEventListener('change', ()=> showCriacao('conv'));
  els.tabPesquisa?.addEventListener('change', ()=> showCriacao('pesq'));
  els.tabCriacao?.addEventListener('change',  ()=> showCriacao('cri'));

  // Inicialização
  renderBotMenu();
  renderForm('Modelo Padrão');
})();
</script>
<script>
(function(){
  // Garante mapa global (arquivo → fileId) para salvar no Drive quando necessário
  window.DRIVE_FILE_MAP = window.DRIVE_FILE_MAP || Object.create(null);

  // Baixa arquivo do Drive preservando formato.
  // - Google Docs nativo → exporta como DOCX
  // - Demais → alt=media, mantendo nome/extensão original
  async function fetchDriveFileAsFile(fileMeta){
    const g = gapi;
    const token = g.client.getToken()?.access_token || '';
    const isGDoc = fileMeta.mimeType === 'application/vnd.google-apps.document';
    if (isGDoc){
      const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileMeta.id)}/export?mimeType=application/vnd.openxmlformats-officedocument.wordprocessingml.document`;
      const resp = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
      if(!resp.ok) throw new Error('Falha ao exportar Google Docs como DOCX');
      const blob = await resp.blob();
      return new File([blob], restoreColons(`${fileMeta.name}.docx`), { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    } else {
      const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileMeta.id)}?alt=media`;
      const resp = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
      if(!resp.ok) throw new Error('Download falhou');
      const ct = resp.headers.get('Content-Type') || '';
      const blob = await resp.blob();
      return new File([blob], restoreColons(fileMeta.name), { type: ct });
    }
  }

  // Sobrescreve importação do Drive para manter formatos originais
  const oldImport = window.importFromDriveFolder;
window.importFromDriveFolder = async function(){
  const folderId = window.DRIVE_FOLDER_ID || DRIVE_FOLDER_ID || '';
  if (!folderId){ openDriveCfg?.(); alert('Informe o Folder ID para importar a pasta do Drive.'); return; }
    try{
      const g = gapi;
      const res = await g.client.drive.files.list({
        q: `'${DRIVE_FOLDER_ID}' in parents and trashed=false`,
        fields: 'files(id,name,mimeType,modifiedTime,size,parents)',
        pageSize: 1000
      });
      const list = res.result?.files || [];
      const allowed = list.filter(f=>{
        const n = (f.name||'').toLowerCase();
        if (f.mimeType === 'application/vnd.google-apps.document') return true;
        return ['.txt','.md','.csv','.json','.log','.html','.htm','.pdf','.docx','.doc'].some(ext => n.endsWith(ext));
      });

      const toAdd = [];
      for (const f of allowed){
        try{
          const fileObj = await fetchDriveFileAsFile(f);
          toAdd.push(fileObj);
          window.DRIVE_FILE_MAP[fileObj.name] = f.id; // para salvar no Drive depois
        }catch(err){ console.warn('Falha ao obter arquivo', f.name, err); }
      }
      if (toAdd.length){
        selectedFiles = (typeof mergeFileLists==='function') ? mergeFileLists(selectedFiles, toAdd) : (selectedFiles||[]).concat(toAdd);
        renderFileList?.();
        (window.renderImportedDocs||function(){})();
      }
      if (els.importStatus){
        setStatus(els.importStatus, toAdd.length ? 'ok' : 'idle',
          toAdd.length ? `Origem: Google Drive (${toAdd.length} arquivo${toAdd.length>1?'s':''})` : 'Origem: Nenhum documento carregado');
      }
      // força reindexação
      window.indexedDocs = [];
    }catch(e){
      console.error(e);
      setStatus(els.importStatus, 'err', 'Origem: falha ao listar pasta do Drive');
      alert('Não foi possível listar a pasta do Drive: ' + (window.prettyError?.(e) || e));
    }
  };

  // Lista de Documentos (modal rápido) — escolher e abrir sem usar a busca
  function openDocList(){
    const list = selectedFiles || [];
    if(!list.length){ alert('Nenhum documento importado.'); return; }
    const ov = document.createElement('div');
    ov.style.cssText='position:fixed;inset:0;background:rgba(0,0,0,.5);z-index:10000;display:flex;align-items:center;justify-content:center;';
    const box = document.createElement('div');
    box.style.cssText='width:min(560px,94vw);max-height:76vh;overflow:auto;background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px;';
    box.innerHTML = '<h3 style="margin:0 0 10px">Documentos importados</h3>';
    const ul = document.createElement('ul'); ul.style.cssText='list-style:none;margin:0;padding:0';
    list.forEach((f)=>{
      const li = document.createElement('li');
      li.style.cssText='padding:8px 10px;border:1px solid var(--border);border-radius:10px;margin-bottom:8px;cursor:pointer;background:#0f1621;';
      li.textContent = f.name;
      li.addEventListener('click', async ()=>{
        try{
          const text = await readFileAsText(f); // já existe no código
          window.selectedDoc = { name: f.name, text, driveFileId: (window.DRIVE_FILE_MAP||{})[f.name] };
          window.editing = false;
          els.searchPreview.contentEditable = 'false';
          els.searchPreview.classList.remove('editing');
          els.searchPreview.textContent = text;
          els.docTitle.textContent = f.name;
          ov.remove();
        }catch(e){ alert('Falha ao abrir: ' + (e.message||e)); }
      });
      ul.appendChild(li);
    });
    const actions = document.createElement('div');
    actions.style.cssText='margin-top:8px;display:flex;justify-content:flex-end;gap:8px';
    const btnFechar = document.createElement('button'); btnFechar.className='btn ghost'; btnFechar.textContent='Fechar';
    btnFechar.addEventListener('click', ()=> ov.remove());
    actions.appendChild(btnFechar);
    box.appendChild(ul); box.appendChild(actions); ov.appendChild(box); document.body.appendChild(ov);
  }

  // Liga o botão "Lista de Documentos" (habilita/desabilita conforme houver arquivos)
  const btnDocList = document.getElementById('btnDocList');
  if(btnDocList){
    btnDocList.addEventListener('click', openDocList);
    const origRenderImported = window.renderImportedDocs;
    window.renderImportedDocs = function(){
      origRenderImported?.();
      btnDocList.disabled = !(selectedFiles && selectedFiles.length);
    };
    btnDocList.disabled = !(selectedFiles && selectedFiles.length);
  }

  // Salvar local (DOCX) SEM Drive — e não exigir selectedDoc se houver texto na prévia
  (function(){
    const btnSave = document.getElementById('btnSaveLocal');
    if(btnSave){
      const newBtn = btnSave.cloneNode(true);
      btnSave.replaceWith(newBtn);
      newBtn.addEventListener('click', async ()=>{
        try{
          if(!window.docx){ alert('Biblioteca DOCX não carregada.'); return; }
          const { Document, Packer, Paragraph, TextRun } = docx;
          const title = (els.docTitle?.textContent || '').trim() || (selectedDoc?.name) || 'documento';
          const base  = title.replace(/\.[^.]+$/, '');
          const text  = (window.editing ? els.searchPreview.textContent : (selectedDoc?.text||els.searchPreview.textContent||''));
          if(!text){ alert('Nada para salvar.'); return; }

          function mdRuns(line){
            const out=[]; const re=/(\*\*[^*]+\*\*|\*[^*]+\*|__[^_]+__|_[^_]+_)/g; let i=0,m;
            while((m=re.exec(line))){
              if(m.index>i) out.push(new TextRun({ text:line.slice(i,m.index), font:'Arial', size:20 }));
              const raw=m[0], inner=raw.replace(/^\*\*|\*\*$|^__|__$/g,'').replace(/^\*|\*$|^_|_$/g,'');
              const b=raw.startsWith('**')||raw.startsWith('__'); const it=(!b)&&(raw.startsWith('*')||raw.startsWith('_'));
              out.push(new TextRun({ text:inner, bold:b, italics:it, font:'Arial', size:20 })); i=re.lastIndex;
            }
            if(i<line.length) out.push(new TextRun({ text:line.slice(i), font:'Arial', size:20 }));
            return out.length?out:[ new TextRun({ text:' ', font:'Arial', size:20 }) ];
          }
          const children = [
            new Paragraph({ children:[ new TextRun({ text: title, bold:true, font:'Arial', size:28 }) ] }),
            new Paragraph({ children:[ new TextRun({ text:'', font:'Arial', size:20 }) ] }),
          ];
          String(text).split('\n').forEach(l=> children.push(new Paragraph({ children: mdRuns(l) })));
          const docxDoc = new Document({ sections:[{ properties:{}, children }] });
          const blob = await Packer.toBlob(docxDoc);
          const url = URL.createObjectURL(blob);
          const a = Object.assign(document.createElement('a'), { href:url, download:`${base}.docx`, style:'display:none' });
          document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 300);
        }catch(e){ console.error(e); alert('Falha ao salvar localmente: ' + (e.message||e)); }
      });
    }
// (removido) — “Salvar Cópia” não é mais necessário
  })();
})();
</script>
<script>
// Habilita o botão "Salvar" apenas quando o modo de edição estiver ativo
(function guardSaveOnEdit(){
  if (els.btnSaveLocal){
    // desabilita por padrão
    els.btnSaveLocal.disabled = true;

    function syncSaveEnabled(){
      const isEd = (els.searchPreview?.isContentEditable === true) || els.searchPreview?.classList?.contains('editing');
      els.btnSaveLocal.disabled = !isEd;
    }

    // sempre que clicar em EDITAR, reavalia o estado
    els.btnEdit?.addEventListener('click', ()=> setTimeout(syncSaveEnabled, 0));
    // ao perder foco da prévia, também reavalia (caso EDITAR desligue por outro fluxo)
    els.searchPreview?.addEventListener('blur', ()=> setTimeout(syncSaveEnabled, 0));
    // ao carregar um documento por clique na lista, o Bloco 3 já força disabled=true
  }
})();
</script>
<script>
// "Salvar" local: grava somente na sessão (sem download/Drive) e só fica habilitado em modo Editar
(function bindSaveStateOnly(){
  const btn = document.getElementById('btnSaveLocal');
  const preview = document.getElementById('searchPreview');
  if(!btn || !preview) return;

  // remove listeners antigos
  const clone = btn.cloneNode(true);
  btn.replaceWith(clone);
  els.btnSaveLocal = clone;

  // começa desabilitado
  clone.disabled = true;

  function isEditing(){
    return preview.isContentEditable === true || preview.classList.contains('editing');
  }

  // habilita/desabilita ao alternar edição
  els.btnEdit?.addEventListener('click', ()=> setTimeout(()=>{ clone.disabled = !isEditing(); }, 0));
  preview.addEventListener('input', ()=>{ if(isEditing()) clone.disabled = false; });

  // salvar apenas atualiza o estado em memória
  clone.addEventListener('click', ()=>{
    if(!isEditing()){ alert('Ative o modo Editar para salvar.'); return; }
    const text = String(preview.textContent || '');
    const name = (els.docTitle?.textContent || selectedDoc?.name || 'documento');
    // garante objeto selecionado
    if(!window.selectedDoc){ window.selectedDoc = { name, text, driveFileId: (window.DRIVE_FILE_MAP||{})[name] }; }
    window.selectedDoc.text = text;
    // feedback discreto
    if(els.importStatus) setStatus(els.importStatus, 'ok', 'Edição salva na sessão');
    // desabilita até nova edição
    clone.disabled = true;
  });
})();
</script>
<script>
// "Salvar" (Pesquisa): grava somente na sessão (sem download/Drive), só habilita em modo Editar e ENCERRA a edição ao salvar
(function bindSaveStateOnly(){
  const btn = document.getElementById('btnSaveLocal');
  const preview = document.getElementById('searchPreview');
  if(!btn || !preview) return;

  // remove listeners antigos
  const clone = btn.cloneNode(true);
  btn.replaceWith(clone);
  els.btnSaveLocal = clone;

  // começa desabilitado
  clone.disabled = true;

  function isEditing(){
    return preview.isContentEditable === true || preview.classList.contains('editing');
  }
  function enableIfEditing(){
    clone.disabled = !isEditing();
  }

  // alternância do modo editar
  els.btnEdit?.addEventListener('click', ()=> setTimeout(enableIfEditing, 0));
  preview.addEventListener('input', ()=>{ if(isEditing()) clone.disabled = false; });

  // salvar = gravar em memória + encerrar edição
  clone.addEventListener('click', ()=>{
    if(!isEditing()){ alert('Ative o modo Editar para salvar.'); return; }
    const text = String(preview.textContent || '');
    const name = (els.docTitle?.textContent || selectedDoc?.name || 'documento');
    if(!window.selectedDoc){ window.selectedDoc = { name, text, driveFileId: (window.DRIVE_FILE_MAP||{})[name] }; }
    window.selectedDoc.text = text;

    // ENCERRA edição
    preview.contentEditable = 'false';
    preview.classList.remove('editing');
    window.editing = false;

    // feedback + desabilita até nova edição
    if(els.importStatus) setStatus(els.importStatus, 'ok', 'Edição salva na sessão');
    clone.disabled = true;
  });
})();
</script>
<script>
/* ===== Side Nav Conversor – links de apps, abas internas e ajuda ===== */
window.APP_LINKS = window.APP_LINKS || {
  workspace:   'https://hdspcorp.github.io/Workspace-Plus/',
  conversor:   'https://hdspcorp.github.io/Conversor-Plus/',
  transmissor: 'https://hdspcorp.github.io/Transmissor-Plus/',
  current:     'conversor'
};

window.addEventListener('DOMContentLoaded', function(){
  // 1) Apps: links e estado "ativo"
  document.querySelectorAll('.sn-btn[data-app]').forEach(a=>{
    const app = a.getAttribute('data-app');
    if (window.APP_LINKS[app]) a.setAttribute('href', window.APP_LINKS[app]);
    a.classList.toggle('active', window.APP_LINKS.current === app);
  });

  // 2) Abas internas: acionam os radios existentes (DOM preservado no header oculto)
  const views = {
    conversor: { tab: document.getElementById('tabConversor'), panel: document.getElementById('viewConversor') },
    pesquisa:  { tab: document.getElementById('tabPesquisa'),  panel: document.getElementById('viewPesquisa')  },
    criacao:   { tab: document.getElementById('tabCriacao'),   panel: document.getElementById('viewCriacao')   }
  };
  function show(name){
    const v = views[name]; if(!v) return;
    if (v.tab){ v.tab.checked = true; v.tab.dispatchEvent(new Event('change', {bubbles:true})); }
    // fallback visual caso o script original não trate os radios
    Object.values(views).forEach(obj=>{ if(obj.panel){ obj.panel.style.display = (obj===v) ? '' : 'none'; } });
    // feedback de seleção no menu interno
    document.querySelectorAll('.sn-btn[data-view]').forEach(x => x.classList.toggle('active', x.getAttribute('data-view')===name));
  }
  document.querySelectorAll('.sn-btn[data-view]').forEach(a=>{
    a.addEventListener('click', (e)=>{ e.preventDefault(); show(a.getAttribute('data-view')); });
  });
  // inicia na aba Conversor
  show('conversor');

  // 3) Conectar/Desconectar (aciona os botões já existentes no header oculto)
  const btnConn = document.getElementById('btnDriveConnectTop') || document.getElementById('cfgConnect');
  const btnDisc = document.getElementById('btnDriveDisconnectTop') || document.getElementById('cfgDisconnect');
  document.querySelector('.sn-btn[data-action="connect"]')?.addEventListener('click', (e)=>{ e.preventDefault(); btnConn?.click(); });
  document.querySelector('.sn-btn[data-action="disconnect"]')?.addEventListener('click', (e)=>{ e.preventDefault(); btnDisc?.click(); });

  // 4) Ajuda: usa a mesma .help-bubble existente, ancorada ao container
  const shell   = document.querySelector('.app-frame');
  const nav     = document.querySelector('.side-nav');
  const bubble  = document.querySelector('.help-bubble');
  const fab     = document.querySelector('.help-fab');
  const helpBtn = document.querySelector('.sn-btn[data-app="ajuda"]');

  if (bubble && shell && nav){
    if (fab) fab.style.display = 'none';
    shell.appendChild(bubble);
    bubble.style.position = 'absolute';
    bubble.style.right = 'auto';
    bubble.style.display = 'none';
    bubble.style.zIndex = '1300';
    const place = () => {
      const left = nav.offsetLeft + nav.offsetWidth + 12;
      bubble.style.left = left + 'px';
      bubble.style.bottom = '24px';
      bubble.style.maxWidth = 'min(560px, calc(100% - ' + (left + 36) + 'px))';
    };
    place(); window.addEventListener('resize', place);

    let open=false;
    helpBtn?.addEventListener('click', (e)=>{ e.preventDefault(); open=!open; bubble.style.display = open ? 'block' : 'none'; });
  }
});
</script>
</div>
<style id="conversor-modal-and-dots">
  .sn-btn.sn-sm{ width:36px; height:36px; }
  .sn-dot{ width:10px; height:10px; border-radius:50%; display:none; border:1px solid var(--border); background:#9aa4b2; }
  .sn-dot.ok{ background:#16a34a; }
  .sn-dot.err{ background:#ef4444; }
  .sn-dot.idle{ background:#9aa4b2; }
  /* Modal documentos */
  #docsModal{ display:none; position:fixed; inset:0; z-index:9999; align-items:center; justify-content:center; background:rgba(0,0,0,.5); }
  #docsModal .box{ width:min(720px,94vw); background:var(--card); border:1px solid var(--border); border-radius:14px; padding:14px; box-shadow:0 20px 50px rgba(0,0,0,.45); }
  #docsModal .box h3{ margin:0 0 10px 0; display:flex; align-items:center; justify-content:space-between; }
  #docsModalClose{ border:1px solid var(--border); border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); color:var(--fg); width:36px; height:36px; display:grid; place-items:center; }
</style>

<!-- Modal: Documentos importados -->
<div id="docsModal">
  <div class="box">
    <h3>Documentos importados
      <button id="docsModalClose" title="Fechar" type="button" aria-label="Fechar">
        ✕
      </button>
    </h3>
    <ul id="importedDocs" class="list" style="max-height:min(64vh,520px); overflow:auto"></ul>
  </div>
</div>

<script>
/* Abre/fecha modal e integra com a indexação de pesquisa + dots na barra */
(function conversorExtras(){
  const btnModal = document.getElementById('btnDocsModalOpen');
  const modal    = document.getElementById('docsModal');
  const closeBtn = document.getElementById('docsModalClose');
  btnModal?.addEventListener('click', ()=>{ modal.style.display='flex'; });
  closeBtn?.addEventListener('click', ()=>{ modal.style.display='none'; });
  modal?.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });

  // Mostrar os "bolinhas" só na aba PESQUISA
  const snGroup = document.getElementById('snStatusGroup');
  function toggleDots(view){ if (snGroup) snGroup.style.display = (view==='pesquisa') ? 'grid' : 'none'; }

  // Hook na função show(view) já existente
  const _show = window.show;
  window.show = function(name){ try{ toggleDots(name); }catch(_){}; return _show ? _show(name) : undefined; };
  toggleDots('conversor'); // estado inicial

  // Atualiza dots quando setStatus() é chamado
  const snDrive = document.getElementById('snDriveDot');
  const snImp   = document.getElementById('snImportDot');
  const _setStatus = window.setStatus;
  window.setStatus = function(el, state, text){
    if (_setStatus) _setStatus(el, state, text);
    const cls = state ? state : 'idle';
    if (el && el.id === 'driveStatus'  && snDrive){ snDrive.className = 'sn-dot ' + cls; }
    if (el && el.id === 'importStatus' && snImp  ){ snImp.className   = 'sn-dot ' + cls; }
  };
})();
</script>

<script>
/* ====== Busca Full-Text com título (patch não-invasivo) ======
   - Indexa arquivo inteiro + TÍTULO (nome do arquivo) 
   - Respeita: Maiúsc/minúsc, Palavra inteira, Ignorar acentos
   - Mantém IDs/fluxos existentes (renderImportedDocs, selectedFiles, etc.)
*/
(function fulltextSearchPatch(){
  const { searchInput, searchCase, searchWhole, searchDiacritics, searchList, searchPreview, docTitle } = els || {};
  if (!searchInput || !searchList || !searchPreview) return;

  let ftIndex = []; // [{ name, text, full, norm, map, textOffset }]

  function fold(s){ return String(s||'').normalize('NFD').replace(/\p{M}+/gu, ''); }
  function foldWithMap(s){
    s = String(s||'');
    let norm = '', map = [];
    for(let i=0;i<s.length;i++){
      const f = s[i].normalize('NFD').replace(/\p{M}+/gu,'');
      for(let k=0;k<f.length;k++){ norm += f[k]; map.push(i); }
    }
    return { norm, map };
  }
  function buildRegex(q, {caseSensitive, wholeWord}){
    const esc = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const pat = wholeWord ? `\\b${esc}\\b` : esc;
    return new RegExp(pat, caseSensitive ? 'g' : 'gi');
  }

  async function ensureIndexAll(){
    ftIndex = [];
    for (const f of (window.selectedFiles||[])){
      try{
        const txt = await readFileAsText(f);
        const title = String(f.name||'');
        const full  = title + '\n' + txt; // inclui TÍTULO
        const { norm, map } = foldWithMap(full);
        ftIndex.push({ name:f.name, text:txt, full, norm, map, textOffset: title.length + 1 });
      }catch(_){}
    }
  }

  function hlEscape(s){ return String(s||'').replace(/[&<>]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[m])); }

  function highlightExcerpt(raw, start, end, matchStart, matchEnd){
    const pre  = hlEscape(raw.slice(start, matchStart));
    const mid  = hlEscape(raw.slice(matchStart, matchEnd));
    const post = hlEscape(raw.slice(matchEnd, end));
    return pre + '<mark>' + mid + '</mark>' + post;
  }

  function doSearch(){
    const qRaw = searchInput.value || '';
    const cs   = !!(searchCase && searchCase.checked);
    const ww   = !!(searchWhole && searchWhole.checked);
    const ignD = !!(searchDiacritics && searchDiacritics.checked);

    searchList.innerHTML = '';
    searchPreview.textContent = '';
    docTitle && (docTitle.textContent = '(nenhum documento selecionado)');

    if (!qRaw.trim()){ return; }

    const q = ignD ? fold(qRaw) : qRaw;
    const re = buildRegex(q, {caseSensitive: cs, wholeWord: ww});

    const results = [];

    for (const d of ftIndex){
      let hay = ignD ? d.norm : d.full;
      let baseIdx = 0; // índice baseado na string pesquisada
      let m;
      while ((m = re.exec(hay)) !== null){
        const idxStart = ignD ? d.map[m.index] : m.index;
        const idxEnd   = ignD ? d.map[Math.max(0, m.index + m[0].length - 1)] + 1 : (m.index + m[0].length);

        // delimita recorte no TEXTO (ignora título), mas se o match for no título mostramos início do texto
        const startBound = Math.max(d.textOffset, idxStart - 500);
        const endBound   = Math.min(d.full.length, idxEnd + 1000);

        results.push({
          name: d.name,
          matchStart: idxStart,
          matchEnd: idxEnd,
          excerpt: highlightExcerpt(d.full, startBound, endBound, idxStart, idxEnd),
          fullRef: d // p/ abrir no preview
        });

        // evita loops infinitos com regexs vazias
        if (m[0].length === 0){ re.lastIndex++; }
      }
    }

    // render
    if (!results.length){
      searchList.innerHTML = '<div class="muted">(sem resultados)</div>';
      return;
    }

    results.sort((a,b)=> a.name.localeCompare(b.name));

    for (const r of results){
      const item = document.createElement('div');
      item.className = 'result-item';
      item.innerHTML = `<strong>${hlEscape(r.name)}</strong><div style="margin-top:6px;font-size:12px">${r.excerpt}</div>`;
      item.addEventListener('click', ()=>{
        const d = r.fullRef;
        // abre documento no preview (apenas TEXTO, sem título)
        const text = d.text;
        const adjStart = Math.max(0, r.matchStart - d.textOffset);
        const adjEnd   = Math.max(adjStart, r.matchEnd - d.textOffset);
        searchPreview.innerHTML = highlightExcerpt(text, Math.max(0, adjStart-500), Math.min(text.length, adjEnd+1000), adjStart, adjEnd);
        if (docTitle) docTitle.textContent = d.name;
        window.selectedDoc = { name:d.name, text:d.text };
      });
      searchList.appendChild(item);
    }
  }

  // Garante reindexação quando documentos mudam: “cola” no renderImportedDocs existente
  if (window.renderImportedDocs){
    const _render = window.renderImportedDocs;
    window.renderImportedDocs = async function(){
      const out = _render.apply(this, arguments);
      try{ await ensureIndexAll(); doSearch(); }catch(_){}
      return out;
    };
  } else {
    // fallback inicial
    ensureIndexAll().then(doSearch).catch(()=>{});
  }

  searchInput.addEventListener('input', doSearch);
  searchCase?.addEventListener('change', doSearch);
  searchWhole?.addEventListener('change', doSearch);
  searchDiacritics?.addEventListener('change', doSearch);
})();
</script>
<script>
/* Patch full-text: título+conteúdo, TODAS as ocorrências (agrupadas) */
(function fulltextAllOccurrences(){
  if (window.__FT_OCC_PATCH__) return; window.__FT_OCC_PATCH__=true;
  const elsRef = window.els || {};
  const searchInput = elsRef.searchInput;
  const searchList  = elsRef.searchList;
  const searchPreview = elsRef.searchPreview;
  const docTitle = elsRef.docTitle;
  if (!searchInput || !searchList || !searchPreview) return;

  // reindexa tudo (título + conteúdo)
  let ftIndex = [];
  function fold(s){ return String(s||'').normalize('NFD').replace(/\p{M}+/gu,''); }
  function buildRegex(q, cs, ww){
    const esc=q.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
    const pat= ww?`\\b${esc}\\b`:esc; return new RegExp(pat, cs?'g':'gi');
  }
  function foldWithMap(s){
    s=String(s||''); let norm='', map=[];
    for(let i=0;i<s.length;i++){ const f=s[i].normalize('NFD').replace(/\p{M}+/gu,''); for(let k=0;k<f.length;k++){ norm+=f[k]; map.push(i); } }
    return { norm, map };
  }
  async function ensureIndexAll(){
    ftIndex=[];
    for (const f of (window.selectedFiles||[])){
      try{
        const txt = await readFileAsText(f);
        const title = String(f.name||'');
        const full = title+'\n'+txt;
        const {norm,map}=foldWithMap(full);
        ftIndex.push({ name:f.name, text:txt, full, norm, map, textOffset:title.length+1 });
      }catch(_){}
    }
  }
  function escHTML(s){ return String(s||'').replace(/[&<>]/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[m])); }
  function highlight(raw, start, end, m0, m1){
    return escHTML(raw.slice(start,m0))+'<mark>'+escHTML(raw.slice(m0,m1))+'</mark>'+escHTML(raw.slice(m1,end));
  }
  function render(resByDoc){
    searchList.innerHTML='';
    const docs=Object.keys(resByDoc).sort((a,b)=>a.localeCompare(b));
    if(!docs.length){ searchList.innerHTML='<div class="muted">(sem resultados)</div>'; return; }
    for (const name of docs){
      const group=document.createElement('div'); group.className='result-item';
      const head=document.createElement('div');
      const items=resByDoc[name];
      head.style.display='flex'; head.style.alignItems='center'; head.style.justifyContent='space-between';
      head.innerHTML=`<strong>${escHTML(name)}</strong><span class="pill">Ocorrências: ${items.length}</span>`;
      const list=document.createElement('div'); list.style.marginTop='8px'; list.style.display='grid'; list.style.gap='8px';
      for(const r of items){
        const it=document.createElement('div');
        it.style.border='1px solid var(--border)'; it.style.borderRadius='10px'; it.style.padding='8px'; it.style.background='#0f1621';
        it.innerHTML=`<div style="font-size:12px">${r.excerpt}</div>`;
        it.addEventListener('click',()=>{
          const d=r.fullRef; const text=d.text;
          const s=Math.max(0, r.matchStart-d.textOffset); const e=Math.max(s, r.matchEnd-d.textOffset);
          searchPreview.innerHTML=highlight(text, Math.max(0,s-500), Math.min(text.length,e+1000), s, e);
          if (docTitle) docTitle.textContent=d.name;
          window.selectedDoc={ name:d.name, text:d.text };
        });
        list.appendChild(it);
      }
      group.appendChild(head); group.appendChild(list); searchList.appendChild(group);
    }
  }
  function doSearch(){
    const cs   = !!(elsRef.searchCase && elsRef.searchCase.checked);
    const ww   = !!(elsRef.searchWhole && elsRef.searchWhole.checked);
    const ignD = !!(elsRef.searchDiacritics && elsRef.searchDiacritics.checked);
    const qRaw = searchInput.value||'';
    searchList.innerHTML=''; searchPreview.textContent=''; if(docTitle) docTitle.textContent='(nenhum documento selecionado)';
    if(!qRaw.trim()) return;
    const q = ignD ? fold(qRaw) : qRaw;
    const re = buildRegex(q, cs, ww);
    const resByDoc = {};
    for(const d of ftIndex){
      const hay = ignD ? d.norm : d.full;
      let m;
      while((m=re.exec(hay))!==null){
        const s = ignD ? d.map[m.index] : m.index;
        const e = ignD ? d.map[Math.max(0, m.index+m[0].length-1)]+1 : (m.index+m[0].length);
        const clipS = Math.max(d.textOffset, s-500);
        const clipE = Math.min(d.full.length, e+1000);
        (resByDoc[d.name] ||= []).push({ fullRef:d, matchStart:s, matchEnd:e, excerpt:highlight(d.full, clipS, clipE, s, e) });
        if(m[0].length===0) re.lastIndex++; // segurança
      }
    }
    render(resByDoc);
  }
  // garante listeners únicos (sem interferir no restante da app)
  (async function initSearch(){
    await ensureIndexAll();
    // reindexar quando a lista de importados for refeita
    if (window.renderImportedDocs){
      const _render = window.renderImportedDocs;
      window.renderImportedDocs = async function(){
        const out=_render.apply(this, arguments);
        try{ await ensureIndexAll(); doSearch(); }catch(_){}
        return out;
      };
    }
    // liga entradas
    searchInput.removeEventListener && searchInput.replaceWith && (function(){
      const cl=searchInput.cloneNode(true); cl.value=searchInput.value; searchInput.parentNode.replaceChild(cl,searchInput);
      if (window.els) window.els.searchInput = cl;
      cl.addEventListener('input', doSearch);
      elsRef.searchCase?.addEventListener('change', doSearch);
      elsRef.searchWhole?.addEventListener('change', doSearch);
      elsRef.searchDiacritics?.addEventListener('change', doSearch);
    })();
  })();
})();
</script>
<style id="patch-ajuste-pesquisa-analise">
  /* ——— Padronizar altura útil das abas (mesma “respiração” vertical) ——— */
  #viewConversor > .grid,
  #viewPesquisa  > .grid,
  #viewCriacao   > .grid,
  #viewAnalise   > .grid{
    min-height: calc(100vh - 180px);
  }

  /* ——— Pesquisa: duas colunas com alturas exatamente iguais ——— */
  #viewPesquisa .grid{ align-items: stretch; }
  #viewPesquisa .card.col-4{
    display: flex;
    flex-direction: column;
    height: calc(100vh - 180px);
    overflow: auto;
  }
  #viewPesquisa .preview-card{
    display: flex;
    flex-direction: column;
    height: calc(100vh - 180px);
  }

  /* A lista deve crescer até ocupar o card da esquerda */
  #searchList{
    flex: 1;
    min-height: 0;
    overflow: auto;
  }

  /* A prévia deve crescer até ocupar o card da direita (sem min-height antigo) */
  #searchPreview{
    flex: 1;
    min-height: 0;
    overflow: auto;
    white-space: pre-wrap; /* preserva quebras/“espaçamentos” do texto */
  }

  /* Análise: impedir que “passe” do viewport em telas menores */
  #viewAnalise > .grid{
    max-height: calc(100vh - 180px);
    overflow: auto;
  }

  /* Estado visual do botão EDITAR quando ativo (apenas cor, mantém o ícone) */
  #btnEdit.active{
    background: linear-gradient(180deg, rgba(34,211,238,.25), rgba(96,165,250,.20));
    border-color: rgba(96,165,250,.35);
  }
</style>

<script id="patch-editar-e-preview">
(function(){
  /* ——— EDITAR: manter só o ícone e trocar apenas cor/estado ——— */
  const preview = document.getElementById('searchPreview');
  const btnEdit = document.getElementById('btnEdit');
  if(preview && btnEdit){
    const clone = btnEdit.cloneNode(true);
    btnEdit.replaceWith(clone);

    function setEdit(on){
      preview.contentEditable = on ? 'true' : 'false';
      preview.classList.toggle('editing', on);
      clone.classList.toggle('active', on);
      clone.setAttribute('aria-pressed', on ? 'true' : 'false');
    }
    clone.addEventListener('click', ()=>{
      const on = !(preview.isContentEditable || preview.classList.contains('editing'));
      setEdit(on);
    });
  }

  /* ——— Prévia: respeitar negritos/itálicos simples (Markdown) sem mexer no backend ———
     - Só transforma quando a prévia vier como texto puro.
     - Se já existir HTML (ex.: <mark> dos realces), não toca. */
  (function enhancePreviewBold(){
    const el = document.getElementById('searchPreview');
    if(!el) return;

    const escapeHTML = s => s
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

    const mdToHTML = s => {
      // **negrito** ou __negrito__
      s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
           .replace(/__(.+?)__/g,      '<strong>$1</strong>');
      // *itálico* ou _itálico_
      s = s.replace(/(^|[^*])\*(?!\s)(.+?)\*(?!\*)/g, '$1<em>$2</em>')
           .replace(/(^|[^_])_(?!\s)(.+?)_(?!_)/g,     '$1<em>$2</em>');
      return s;
    };

    const obs = new MutationObserver(()=>{
      // se já tem elementos (ex.: <mark>), não converter
      if(el.querySelector('*')) return;
      const raw = el.textContent ?? '';
      const html = mdToHTML(escapeHTML(raw));
      if(html !== raw){
        obs.disconnect();
        el.innerHTML = html; // white-space: pre-wrap preserva espaçamentos/linhas
        obs.observe(el, { childList:true, characterData:true, subtree:true });
      }
    });
    obs.observe(el, { childList:true, characterData:true, subtree:true });
  })();
})();
</script>
</body>
</html>
